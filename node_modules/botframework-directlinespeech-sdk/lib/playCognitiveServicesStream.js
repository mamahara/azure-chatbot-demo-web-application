"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = playCognitiveServicesStream;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _cognitiveServicesPromiseToESPromise = _interopRequireDefault(require("./cognitiveServicesPromiseToESPromise"));

var _createMultiBufferingPlayer = _interopRequireDefault(require("./createMultiBufferingPlayer"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Safari requires an audio buffer with a sample rate of 22050 Hz.
// Using a minimum sample rate of 44100 Hz as an example, the Speech SDK's default 16000 Hz will be upsampled to 48000 Hz.
var MIN_SAMPLE_RATE = 44100; // The Speech SDK is hardcoded to chop packets to 4096 bytes.
// Web Chat's multi-buffering player is set up with 3 buffers; each is 4096 bytes (2048 16-bit samples).
// For simplicity, the multi-buffer player currently does not support progressive buffering.
// Progressive buffering allows queuing at any sample size and will be concatenated.
// If 1000 samples are queued, then 1048 samples are queued, they will be concatenated into a single buffer of size 2048.
// For simplicity, data will be queued to two buffers.
// The first buffer is 1000 samples followed by 1048 zeroes, and the second buffer is 1048 samples followed by 1000 zeroes.
// There is no plan to support progressive buffering until the Speech SDK chops data at dynamic size.

var DEFAULT_BUFFER_SIZE = 4096;

function average(array) {
  return array.reduce(function (sum, value) {
    return sum + value;
  }, 0) / array.length;
}

function formatTypedBitArrayToFloatArray(audioData, maxValue) {
  var float32Data = new Float32Array(audioData.length);

  for (var i = 0; i < audioData.length; i++) {
    float32Data[i] = audioData[i] / maxValue;
  }

  return float32Data;
}

function formatAudioDataArrayBufferToFloatArray(_ref, arrayBuffer) {
  var bitsPerSample = _ref.bitsPerSample;

  switch (bitsPerSample) {
    case 8:
      return formatTypedBitArrayToFloatArray(new Int8Array(arrayBuffer), 128);

    case 16:
      return formatTypedBitArrayToFloatArray(new Int16Array(arrayBuffer), 32768);

    case 32:
      return formatTypedBitArrayToFloatArray(new Int32Array(arrayBuffer), 2147483648);

    default:
      throw new Error('Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time');
  }
}

function abortToReject(signal) {
  return new Promise(function (_, reject) {
    signal.onabort = function () {
      return reject(new Error('aborted'));
    };
  });
} // In a 2 channel audio (e.g. A/B), the data arrives as interleaved, like "ABABABABAB".
// This function will take "ABABABABAB" and return an array ["AAAAA", "BBBBB"].


function deinterleave(channelInterleavedAudioData, _ref2) {
  var channels = _ref2.channels;
  var multiChannelArrayBuffer = new Array(channels);
  var frameSize = channelInterleavedAudioData.length / channels;

  for (var channel = 0; channel < channels; channel++) {
    var audioData = new Float32Array(frameSize);
    multiChannelArrayBuffer[channel] = audioData;

    for (var offset = 0; offset < frameSize; offset++) {
      audioData[offset] = channelInterleavedAudioData[offset * channels + channel];
    }
  }

  return multiChannelArrayBuffer;
} // This function upsamples the audio data via an integer multiplier.
// Web Chat uses simple anti-aliasing. For simplicity, the anti-aliasing does not roll over to next buffer.


function multiplySampleRate(source, sampleRateMultiplier) {
  if (sampleRateMultiplier === 1) {
    return source;
  }

  var lastValues = new Array(sampleRateMultiplier).fill(source[0]);
  var target = new Float32Array(source.length * sampleRateMultiplier);

  for (var sourceOffset = 0; sourceOffset < source.length; sourceOffset++) {
    var value = source[sourceOffset];
    var targetOffset = sourceOffset * sampleRateMultiplier;

    for (var multiplierIndex = 0; multiplierIndex < sampleRateMultiplier; multiplierIndex++) {
      lastValues.shift();
      lastValues.push(value);
      target[targetOffset + multiplierIndex] = average(lastValues);
    }
  }

  return target;
}

function playCognitiveServicesStream(_x, _x2, _x3) {
  return _playCognitiveServicesStream.apply(this, arguments);
}

function _playCognitiveServicesStream() {
  _playCognitiveServicesStream = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(audioContext, audioFormat, streamReader) {
    var _ref3,
        _ref3$signal,
        signal,
        queuedBufferSourceNodes,
        _args2 = arguments;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref3 = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {}, _ref3$signal = _ref3.signal, signal = _ref3$signal === void 0 ? {} : _ref3$signal;
            queuedBufferSourceNodes = [];
            _context2.prev = 2;
            return _context2.delegateYield( /*#__PURE__*/_regenerator.default.mark(function _callee() {
              var abortPromise, read, newSamplesPerSec, sampleRateMultiplier, player, chunk, maxChunks, interleavedArray, multiChannelArray, upsampledMultiChannelArray;
              return _regenerator.default.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      abortPromise = abortToReject(signal);

                      read = function read() {
                        return Promise.race([// Abort will gracefully end the queue. We will check signal.aborted later to throw abort exception.
                        abortPromise.catch(function () {
                          return {
                            isEnd: true
                          };
                        }), (0, _cognitiveServicesPromiseToESPromise.default)(streamReader.read())]);
                      };

                      if (!signal.aborted) {
                        _context.next = 4;
                        break;
                      }

                      throw new Error('aborted');

                    case 4:
                      newSamplesPerSec = audioFormat.samplesPerSec;
                      sampleRateMultiplier = 1; // Safari requires a minimum sample rate of 22100 Hz.
                      // A multiplier is calculated the the data meets the minimum sample rate.
                      // An integer-based multiplier to simplify our upsampler.
                      // For security, data will only be upsampled up to 96000 Hz.

                      while (newSamplesPerSec < MIN_SAMPLE_RATE && newSamplesPerSec < 96000) {
                        sampleRateMultiplier++;
                        newSamplesPerSec = audioFormat.samplesPerSec * sampleRateMultiplier;
                      } // The third parameter is the sample size in bytes.
                      // For example, if the Speech SDK sends Web Chat 4096 bytes of 16-bit samples, there will be 2048 samples per channel.
                      // The multi-buffering player is set up to handle 2048 samples per buffer.
                      // If the multiplier 3x, it will handle 6144 samples per buffer.


                      player = (0, _createMultiBufferingPlayer.default)(audioContext, _objectSpread(_objectSpread({}, audioFormat), {}, {
                        samplesPerSec: newSamplesPerSec
                      }), DEFAULT_BUFFER_SIZE / (audioFormat.bitsPerSample / 8) * sampleRateMultiplier); // For security, the maximum number of chunks handled will be 1000.

                      _context.next = 10;
                      return read();

                    case 10:
                      chunk = _context.sent;
                      maxChunks = 0;

                    case 12:
                      if (!(!chunk.isEnd && maxChunks < 1000 && !signal.aborted)) {
                        _context.next = 25;
                        break;
                      }

                      if (!signal.aborted) {
                        _context.next = 15;
                        break;
                      }

                      return _context.abrupt("break", 25);

                    case 15:
                      // Data received from Speech SDK is interleaved; 2 channels (e.g. A and B) will be sent as "ABABABABAB"
                      // And each sample (A/B) will be an 8 to 32-bit number.
                      // Convert the 8 - 32-bit number into a floating-point number, as required by Web Audio API.
                      interleavedArray = formatAudioDataArrayBufferToFloatArray(audioFormat, chunk.buffer); // Deinterleave data back into two array buffer, e.g. "AAAAA" and "BBBBB".

                      multiChannelArray = deinterleave(interleavedArray, audioFormat); // Upsample data if necessary. If the multiplier is 2x, "AAAAA" will be upsampled to "AAAAAAAAAA" (with anti-alias).

                      upsampledMultiChannelArray = multiChannelArray.map(function (array) {
                        return multiplySampleRate(array, sampleRateMultiplier);
                      }); // Queue to the buffering player.

                      player.push(upsampledMultiChannelArray);

                    case 19:
                      _context.next = 21;
                      return read();

                    case 21:
                      chunk = _context.sent;
                      maxChunks++;
                      _context.next = 12;
                      break;

                    case 25:
                      abortPromise.catch(function () {
                        return player.cancelAll();
                      });

                      if (!signal.aborted) {
                        _context.next = 28;
                        break;
                      }

                      throw new Error('aborted');

                    case 28:
                      _context.next = 30;
                      return Promise.race([abortPromise, player.flush()]);

                    case 30:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            })(), "t0", 4);

          case 4:
            _context2.prev = 4;
            queuedBufferSourceNodes.forEach(function (node) {
              return node.stop();
            });
            return _context2.finish(4);

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[2,, 4, 7]]);
  }));
  return _playCognitiveServicesStream.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wbGF5Q29nbml0aXZlU2VydmljZXNTdHJlYW0uanMiXSwibmFtZXMiOlsiTUlOX1NBTVBMRV9SQVRFIiwiREVGQVVMVF9CVUZGRVJfU0laRSIsImF2ZXJhZ2UiLCJhcnJheSIsInJlZHVjZSIsInN1bSIsInZhbHVlIiwibGVuZ3RoIiwiZm9ybWF0VHlwZWRCaXRBcnJheVRvRmxvYXRBcnJheSIsImF1ZGlvRGF0YSIsIm1heFZhbHVlIiwiZmxvYXQzMkRhdGEiLCJGbG9hdDMyQXJyYXkiLCJpIiwiZm9ybWF0QXVkaW9EYXRhQXJyYXlCdWZmZXJUb0Zsb2F0QXJyYXkiLCJhcnJheUJ1ZmZlciIsImJpdHNQZXJTYW1wbGUiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkVycm9yIiwiYWJvcnRUb1JlamVjdCIsInNpZ25hbCIsIlByb21pc2UiLCJfIiwicmVqZWN0Iiwib25hYm9ydCIsImRlaW50ZXJsZWF2ZSIsImNoYW5uZWxJbnRlcmxlYXZlZEF1ZGlvRGF0YSIsImNoYW5uZWxzIiwibXVsdGlDaGFubmVsQXJyYXlCdWZmZXIiLCJBcnJheSIsImZyYW1lU2l6ZSIsImNoYW5uZWwiLCJvZmZzZXQiLCJtdWx0aXBseVNhbXBsZVJhdGUiLCJzb3VyY2UiLCJzYW1wbGVSYXRlTXVsdGlwbGllciIsImxhc3RWYWx1ZXMiLCJmaWxsIiwidGFyZ2V0Iiwic291cmNlT2Zmc2V0IiwidGFyZ2V0T2Zmc2V0IiwibXVsdGlwbGllckluZGV4Iiwic2hpZnQiLCJwdXNoIiwicGxheUNvZ25pdGl2ZVNlcnZpY2VzU3RyZWFtIiwiYXVkaW9Db250ZXh0IiwiYXVkaW9Gb3JtYXQiLCJzdHJlYW1SZWFkZXIiLCJxdWV1ZWRCdWZmZXJTb3VyY2VOb2RlcyIsImFib3J0UHJvbWlzZSIsInJlYWQiLCJyYWNlIiwiY2F0Y2giLCJpc0VuZCIsImFib3J0ZWQiLCJuZXdTYW1wbGVzUGVyU2VjIiwic2FtcGxlc1BlclNlYyIsInBsYXllciIsImNodW5rIiwibWF4Q2h1bmtzIiwiaW50ZXJsZWF2ZWRBcnJheSIsImJ1ZmZlciIsIm11bHRpQ2hhbm5lbEFycmF5IiwidXBzYW1wbGVkTXVsdGlDaGFubmVsQXJyYXkiLCJtYXAiLCJjYW5jZWxBbGwiLCJmbHVzaCIsImZvckVhY2giLCJub2RlIiwic3RvcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBSUE7O0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQSxJQUFNQSxlQUFlLEdBQUcsS0FBeEIsQyxDQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBQ0EsSUFBTUMsbUJBQW1CLEdBQUcsSUFBNUI7O0FBRUEsU0FBU0MsT0FBVCxDQUFpQkMsS0FBakIsRUFBd0I7QUFDdEIsU0FBT0EsS0FBSyxDQUFDQyxNQUFOLENBQWEsVUFBQ0MsR0FBRCxFQUFNQyxLQUFOO0FBQUEsV0FBZ0JELEdBQUcsR0FBR0MsS0FBdEI7QUFBQSxHQUFiLEVBQTBDLENBQTFDLElBQStDSCxLQUFLLENBQUNJLE1BQTVEO0FBQ0Q7O0FBRUQsU0FBU0MsK0JBQVQsQ0FBeUNDLFNBQXpDLEVBQW9EQyxRQUFwRCxFQUE4RDtBQUM1RCxNQUFNQyxXQUFXLEdBQUcsSUFBSUMsWUFBSixDQUFpQkgsU0FBUyxDQUFDRixNQUEzQixDQUFwQjs7QUFFQSxPQUFLLElBQUlNLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdKLFNBQVMsQ0FBQ0YsTUFBOUIsRUFBc0NNLENBQUMsRUFBdkMsRUFBMkM7QUFDekNGLElBQUFBLFdBQVcsQ0FBQ0UsQ0FBRCxDQUFYLEdBQWlCSixTQUFTLENBQUNJLENBQUQsQ0FBVCxHQUFlSCxRQUFoQztBQUNEOztBQUVELFNBQU9DLFdBQVA7QUFDRDs7QUFFRCxTQUFTRyxzQ0FBVCxPQUFtRUMsV0FBbkUsRUFBZ0Y7QUFBQSxNQUE5QkMsYUFBOEIsUUFBOUJBLGFBQThCOztBQUM5RSxVQUFRQSxhQUFSO0FBQ0UsU0FBSyxDQUFMO0FBQ0UsYUFBT1IsK0JBQStCLENBQUMsSUFBSVMs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TUFBTSxDQUFDUSxTQUFQLEVBQU47QUFBQSx1QkFBbkI7O0FBeEVXLDJCQTBFUDdDLE1BQU0sQ0FBQ2tDLE9BMUVBO0FBQUE7QUFBQTtBQUFBOztBQUFBLDRCQTJFSCxJQUFJcEMsS0FBSixDQUFVLFNBQVYsQ0EzRUc7O0FBQUE7QUFBQTtBQUFBLDZCQThFTEcsT0FBTyxDQUFDOEIsSUFBUixDQUFhLENBQUNGLFlBQUQsRUFBZVEsTUFBTSxDQUFDUyxLQUFQLEVBQWYsQ0FBYixDQTlFSzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBZ0ZYbEIsWUFBQUEsdUJBQXVCLENBQUNtQixPQUF4QixDQUFnQyxVQUFBQyxJQUFJO0FBQUEscUJBQUlBLElBQUksQ0FBQ0MsSUFBTCxFQUFKO0FBQUEsYUFBcEM7QUFoRlc7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRyIsInNvdXJjZVJvb3QiOiJkaXJlY3RsaW5lc3BlZWNoOi8vLyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby1tYWdpYy1udW1iZXJzOiBbXCJlcnJvclwiLCB7IFwiaWdub3JlXCI6IFswLCAxLCA4LCAxNiwgMzIsIDEyOCwgMTAwMCwgMzI3NjgsIDk2MDAwLCAyMTQ3NDgzNjQ4XSB9XSAqL1xuLyogZXNsaW50IG5vLWF3YWl0LWluLWxvb3A6IFwib2ZmXCIgKi9cbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogXCJvZmZcIiAqL1xuXG5pbXBvcnQgY29nbml0aXZlU2VydmljZXNQcm9taXNlVG9FU1Byb21pc2UgZnJvbSAnLi9jb2duaXRpdmVTZXJ2aWNlc1Byb21pc2VUb0VTUHJvbWlzZSc7XG5pbXBvcnQgY3JlYXRlTXVsdGlCdWZmZXJpbmdQbGF5ZXIgZnJvbSAnLi9jcmVhdGVNdWx0aUJ1ZmZlcmluZ1BsYXllcic7XG5cbi8vIFNhZmFyaSByZXF1aXJlcyBhbiBhdWRpbyBidWZmZXIgd2l0aCBhIHNhbXBsZSByYXRlIG9mIDIyMDUwIEh6LlxuLy8gVXNpbmcgYSBtaW5pbXVtIHNhbXBsZSByYXRlIG9mIDQ0MTAwIEh6IGFzIGFuIGV4YW1wbGUsIHRoZSBTcGVlY2ggU0RLJ3MgZGVmYXVsdCAxNjAwMCBIeiB3aWxsIGJlIHVwc2FtcGxlZCB0byA0ODAwMCBIei5cbmNvbnN0IE1JTl9TQU1QTEVfUkFURSA9IDQ0MTAwO1xuXG4vLyBUaGUgU3BlZWNoIFNESyBpcyBoYXJkY29kZWQgdG8gY2hvcCBwYWNrZXRzIHRvIDQwOTYgYnl0ZXMuXG4vLyBXZWIgQ2hhdCdzIG11bHRpLWJ1ZmZlcmluZyBwbGF5ZXIgaXMgc2V0IHVwIHdpdGggMyBidWZmZXJzOyBlYWNoIGlzIDQwOTYgYnl0ZXMgKDIwNDggMTYtYml0IHNhbXBsZXMpLlxuLy8gRm9yIHNpbXBsaWNpdHksIHRoZSBtdWx0aS1idWZmZXIgcGxheWVyIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHByb2dyZXNzaXZlIGJ1ZmZlcmluZy5cblxuLy8gUHJvZ3Jlc3NpdmUgYnVmZmVyaW5nIGFsbG93cyBxdWV1aW5nIGF0IGFueSBzYW1wbGUgc2l6ZSBhbmQgd2lsbCBiZSBjb25jYXRlbmF0ZWQuXG4vLyBJZiAxMDAwIHNhbXBsZXMgYXJlIHF1ZXVlZCwgdGhlbiAxMDQ4IHNhbXBsZXMgYXJlIHF1ZXVlZCwgdGhleSB3aWxsIGJlIGNvbmNhdGVuYXRlZCBpbnRvIGEgc2luZ2xlIGJ1ZmZlciBvZiBzaXplIDIwNDguXG5cbi8vIEZvciBzaW1wbGljaXR5LCBkYXRhIHdpbGwgYmUgcXVldWVkIHRvIHR3byBidWZmZXJzLlxuLy8gVGhlIGZpcnN0IGJ1ZmZlciBpcyAxMDAwIHNhbXBsZXMgZm9sbG93ZWQgYnkgMTA0OCB6ZXJvZXMsIGFuZCB0aGUgc2Vjb25kIGJ1ZmZlciBpcyAxMDQ4IHNhbXBsZXMgZm9sbG93ZWQgYnkgMTAwMCB6ZXJvZXMuXG5cbi8vIFRoZXJlIGlzIG5vIHBsYW4gdG8gc3VwcG9ydCBwcm9ncmVzc2l2ZSBidWZmZXJpbmcgdW50aWwgdGhlIFNwZWVjaCBTREsgY2hvcHMgZGF0YSBhdCBkeW5hbWljIHNpemUuXG5jb25zdCBERUZBVUxUX0JVRkZFUl9TSVpFID0gNDA5NjtcblxuZnVuY3Rpb24gYXZlcmFnZShhcnJheSkge1xuICByZXR1cm4gYXJyYXkucmVkdWNlKChzdW0sIHZhbHVlKSA9PiBzdW0gKyB2YWx1ZSwgMCkgLyBhcnJheS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFR5cGVkQml0QXJyYXlUb0Zsb2F0QXJyYXkoYXVkaW9EYXRhLCBtYXhWYWx1ZSkge1xuICBjb25zdCBmbG9hdDMyRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYXVkaW9EYXRhLmxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpb0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBmbG9hdDMyRGF0YVtpXSA9IGF1ZGlvRGF0YVtpXSAvIG1heFZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGZsb2F0MzJEYXRhO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBdWRpb0RhdGFBcnJheUJ1ZmZlclRvRmxvYXRBcnJheSh7IGJpdHNQZXJTYW1wbGUgfSwgYXJyYXlCdWZmZXIpIHtcbiAgc3dpdGNoIChiaXRzUGVyU2FtcGxlKSB7XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIGZvcm1hdFR5cGVkQml0QXJyYXlUb0Zsb2F0QXJyYXkobmV3IEludDhBcnJheShhcnJheUJ1ZmZlciksIDEyOCk7XG5cbiAgICBjYXNlIDE2OlxuICAgICAgcmV0dXJuIGZvcm1hdFR5cGVkQml0QXJyYXlUb0Zsb2F0QXJyYXkobmV3IEludDE2QXJyYXkoYXJyYXlCdWZmZXIpLCAzMjc2OCk7XG5cbiAgICBjYXNlIDMyOlxuICAgICAgcmV0dXJuIGZvcm1hdFR5cGVkQml0QXJyYXlUb0Zsb2F0QXJyYXkobmV3IEludDMyQXJyYXkoYXJyYXlCdWZmZXIpLCAyMTQ3NDgzNjQ4KTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgV0FWRV9GT1JNQVRfUENNICg4LzE2LzMyIGJwcykgZm9ybWF0IHN1cHBvcnRlZCBhdCB0aGlzIHRpbWUnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydFRvUmVqZWN0KHNpZ25hbCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgIHNpZ25hbC5vbmFib3J0ID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignYWJvcnRlZCcpKTtcbiAgfSk7XG59XG5cbi8vIEluIGEgMiBjaGFubmVsIGF1ZGlvIChlLmcuIEEvQiksIHRoZSBkYXRhIGFycml2ZXMgYXMgaW50ZXJsZWF2ZWQsIGxpa2UgXCJBQkFCQUJBQkFCXCIuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgdGFrZSBcIkFCQUJBQkFCQUJcIiBhbmQgcmV0dXJuIGFuIGFycmF5IFtcIkFBQUFBXCIsIFwiQkJCQkJcIl0uXG5mdW5jdGlvbiBkZWludGVybGVhdmUoY2hhbm5lbEludGVybGVhdmVkQXVkaW9EYXRhLCB7IGNoYW5uZWxzIH0pIHtcbiAgY29uc3QgbXVsdGlDaGFubmVsQXJyYXlCdWZmZXIgPSBuZXcgQXJyYXkoY2hhbm5lbHMpO1xuICBjb25zdCBmcmFtZVNpemUgPSBjaGFubmVsSW50ZXJsZWF2ZWRBdWRpb0RhdGEubGVuZ3RoIC8gY2hhbm5lbHM7XG5cbiAgZm9yIChsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBjaGFubmVsczsgY2hhbm5lbCsrKSB7XG4gICAgY29uc3QgYXVkaW9EYXRhID0gbmV3IEZsb2F0MzJBcnJheShmcmFtZVNpemUpO1xuXG4gICAgbXVsdGlDaGFubmVsQXJyYXlCdWZmZXJbY2hhbm5lbF0gPSBhdWRpb0RhdGE7XG5cbiAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBmcmFtZVNpemU7IG9mZnNldCsrKSB7XG4gICAgICBhdWRpb0RhdGFbb2Zmc2V0XSA9IGNoYW5uZWxJbnRlcmxlYXZlZEF1ZGlvRGF0YVtvZmZzZXQgKiBjaGFubmVscyArIGNoYW5uZWxdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtdWx0aUNoYW5uZWxBcnJheUJ1ZmZlcjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB1cHNhbXBsZXMgdGhlIGF1ZGlvIGRhdGEgdmlhIGFuIGludGVnZXIgbXVsdGlwbGllci5cbi8vIFdlYiBDaGF0IHVzZXMgc2ltcGxlIGFudGktYWxpYXNpbmcuIEZvciBzaW1wbGljaXR5LCB0aGUgYW50aS1hbGlhc2luZyBkb2VzIG5vdCByb2xsIG92ZXIgdG8gbmV4dCBidWZmZXIuXG5mdW5jdGlvbiBtdWx0aXBseVNhbXBsZVJhdGUoc291cmNlLCBzYW1wbGVSYXRlTXVsdGlwbGllcikge1xuICBpZiAoc2FtcGxlUmF0ZU11bHRpcGxpZXIgPT09IDEpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgY29uc3QgbGFzdFZhbHVlcyA9IG5ldyBBcnJheShzYW1wbGVSYXRlTXVsdGlwbGllcikuZmlsbChzb3VyY2VbMF0pO1xuICBjb25zdCB0YXJnZXQgPSBuZXcgRmxvYXQzMkFycmF5KHNvdXJjZS5sZW5ndGggKiBzYW1wbGVSYXRlTXVsdGlwbGllcik7XG5cbiAgZm9yIChsZXQgc291cmNlT2Zmc2V0ID0gMDsgc291cmNlT2Zmc2V0IDwgc291cmNlLmxlbmd0aDsgc291cmNlT2Zmc2V0KyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtzb3VyY2VPZmZzZXRdO1xuICAgIGNvbnN0IHRhcmdldE9mZnNldCA9IHNvdXJjZU9mZnNldCAqIHNhbXBsZVJhdGVNdWx0aXBsaWVyO1xuXG4gICAgZm9yIChsZXQgbXVsdGlwbGllckluZGV4ID0gMDsgbXVsdGlwbGllckluZGV4IDwgc2FtcGxlUmF0ZU11bHRpcGxpZXI7IG11bHRpcGxpZXJJbmRleCsrKSB7XG4gICAgICBsYXN0VmFsdWVzLnNoaWZ0KCk7XG4gICAgICBsYXN0VmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgdGFyZ2V0W3RhcmdldE9mZnNldCArIG11bHRpcGxpZXJJbmRleF0gPSBhdmVyYWdlKGxhc3RWYWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBsYXlDb2duaXRpdmVTZXJ2aWNlc1N0cmVhbShcbiAgYXVkaW9Db250ZXh0LFxuICBhdWRpb0Zvcm1hdCxcbiAgc3RyZWFtUmVhZGVyLFxuICB7IHNpZ25hbCA9IHt9IH0gPSB7fVxuKSB7XG4gIGNvbnN0IHF1ZXVlZEJ1ZmZlclNvdXJjZU5vZGVzID0gW107XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBhYm9ydFByb21pc2UgPSBhYm9ydFRvUmVqZWN0KHNpZ25hbCk7XG5cbiAgICBjb25zdCByZWFkID0gKCkgPT5cbiAgICAgIFByb21pc2UucmFjZShbXG4gICAgICAgIC8vIEFib3J0IHdpbGwgZ3JhY2VmdWxseSBlbmQgdGhlIHF1ZXVlLiBXZSB3aWxsIGNoZWNrIHNpZ25hbC5hYm9ydGVkIGxhdGVyIHRvIHRocm93IGFib3J0IGV4Y2VwdGlvbi5cbiAgICAgICAgYWJvcnRQcm9taXNlLmNhdGNoKCgpID0+ICh7IGlzRW5kOiB0cnVlIH0pKSxcbiAgICAgICAgY29nbml0aXZlU2VydmljZXNQcm9taXNlVG9FU1Byb21pc2Uoc3RyZWFtUmVhZGVyLnJlYWQoKSlcbiAgICAgIF0pO1xuXG4gICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fib3J0ZWQnKTtcbiAgICB9XG5cbiAgICBsZXQgbmV3U2FtcGxlc1BlclNlYyA9IGF1ZGlvRm9ybWF0LnNhbXBsZXNQZXJTZWM7XG4gICAgbGV0IHNhbXBsZVJhdGVNdWx0aXBsaWVyID0gMTtcblxuICAgIC8vIFNhZmFyaSByZXF1aXJlcyBhIG1pbmltdW0gc2FtcGxlIHJhdGUgb2YgMjIxMDAgSHouXG4gICAgLy8gQSBtdWx0aXBsaWVyIGlzIGNhbGN1bGF0ZWQgdGhlIHRoZSBkYXRhIG1lZXRzIHRoZSBtaW5pbXVtIHNhbXBsZSByYXRlLlxuICAgIC8vIEFuIGludGVnZXItYmFzZWQgbXVsdGlwbGllciB0byBzaW1wbGlmeSBvdXIgdXBzYW1wbGVyLlxuICAgIC8vIEZvciBzZWN1cml0eSwgZGF0YSB3aWxsIG9ubHkgYmUgdXBzYW1wbGVkIHVwIHRvIDk2MDAwIEh6LlxuICAgIHdoaWxlIChuZXdTYW1wbGVzUGVyU2VjIDwgTUlOX1NBTVBMRV9SQVRFICYmIG5ld1NhbXBsZXNQZXJTZWMgPCA5NjAwMCkge1xuICAgICAgc2FtcGxlUmF0ZU11bHRpcGxpZXIrKztcbiAgICAgIG5ld1NhbXBsZXNQZXJTZWMgPSBhdWRpb0Zvcm1hdC5zYW1wbGVzUGVyU2VjICogc2FtcGxlUmF0ZU11bHRpcGxpZXI7XG4gICAgfVxuXG4gICAgLy8gVGhlIHRoaXJkIHBhcmFtZXRlciBpcyB0aGUgc2FtcGxlIHNpemUgaW4gYnl0ZXMuXG4gICAgLy8gRm9yIGV4YW1wbGUsIGlmIHRoZSBTcGVlY2ggU0RLIHNlbmRzIFdlYiBDaGF0IDQwOTYgYnl0ZXMgb2YgMTYtYml0IHNhbXBsZXMsIHRoZXJlIHdpbGwgYmUgMjA0OCBzYW1wbGVzIHBlciBjaGFubmVsLlxuICAgIC8vIFRoZSBtdWx0aS1idWZmZXJpbmcgcGxheWVyIGlzIHNldCB1cCB0byBoYW5kbGUgMjA0OCBzYW1wbGVzIHBlciBidWZmZXIuXG4gICAgLy8gSWYgdGhlIG11bHRpcGxpZXIgM3gsIGl0IHdpbGwgaGFuZGxlIDYxNDQgc2FtcGxlcyBwZXIgYnVmZmVyLlxuICAgIGNvbnN0IHBsYXllciA9IGNyZWF0ZU11bHRpQnVmZmVyaW5nUGxheWVyKFxuICAgICAgYXVkaW9Db250ZXh0LFxuICAgICAgeyAuLi5hdWRpb0Zvcm1hdCwgc2FtcGxlc1BlclNlYzogbmV3U2FtcGxlc1BlclNlYyB9LFxuICAgICAgKERFRkFVTFRfQlVGRkVSX1NJWkUgLyAoYXVkaW9Gb3JtYXQuYml0c1BlclNhbXBsZSAvIDgpKSAqIHNhbXBsZVJhdGVNdWx0aXBsaWVyXG4gICAgKTtcblxuICAgIC8vIEZvciBzZWN1cml0eSwgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNodW5rcyBoYW5kbGVkIHdpbGwgYmUgMTAwMC5cbiAgICBmb3IgKFxuICAgICAgbGV0IGNodW5rID0gYXdhaXQgcmVhZCgpLCBtYXhDaHVua3MgPSAwO1xuICAgICAgIWNodW5rLmlzRW5kICYmIG1heENodW5rcyA8IDEwMDAgJiYgIXNpZ25hbC5hYm9ydGVkO1xuICAgICAgY2h1bmsgPSBhd2FpdCByZWFkKCksIG1heENodW5rcysrXG4gICAgKSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIERhdGEgcmVjZWl2ZWQgZnJvbSBTcGVlY2ggU0RLIGlzIGludGVybGVhdmVkOyAyIGNoYW5uZWxzIChlLmcuIEEgYW5kIEIpIHdpbGwgYmUgc2VudCBhcyBcIkFCQUJBQkFCQUJcIlxuICAgICAgLy8gQW5kIGVhY2ggc2FtcGxlIChBL0IpIHdpbGwgYmUgYW4gOCB0byAzMi1iaXQgbnVtYmVyLlxuXG4gICAgICAvLyBDb252ZXJ0IHRoZSA4IC0gMzItYml0IG51bWJlciBpbnRvIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBhcyByZXF1aXJlZCBieSBXZWIgQXVkaW8gQVBJLlxuICAgICAgY29uc3QgaW50ZXJsZWF2ZWRBcnJheSA9IGZvcm1hdEF1ZGlvRGF0YUFycmF5QnVmZmVyVG9GbG9hdEFycmF5KGF1ZGlvRm9ybWF0LCBjaHVuay5idWZmZXIpO1xuXG4gICAgICAvLyBEZWludGVybGVhdmUgZGF0YSBiYWNrIGludG8gdHdvIGFycmF5IGJ1ZmZlciwgZS5nLiBcIkFBQUFBXCIgYW5kIFwiQkJCQkJcIi5cbiAgICAgIGNvbnN0IG11bHRpQ2hhbm5lbEFycmF5ID0gZGVpbnRlcmxlYXZlKGludGVybGVhdmVkQXJyYXksIGF1ZGlvRm9ybWF0KTtcblxuICAgICAgLy8gVXBzYW1wbGUgZGF0YSBpZiBuZWNlc3NhcnkuIElmIHRoZSBtdWx0aXBsaWVyIGlzIDJ4LCBcIkFBQUFBXCIgd2lsbCBiZSB1cHNhbXBsZWQgdG8gXCJBQUFBQUFBQUFBXCIgKHdpdGggYW50aS1hbGlhcykuXG4gICAgICBjb25zdCB1cHNhbXBsZWRNdWx0aUNoYW5uZWxBcnJheSA9IG11bHRpQ2hhbm5lbEFycmF5Lm1hcChhcnJheSA9PlxuICAgICAgICBtdWx0aXBseVNhbXBsZVJhdGUoYXJyYXksIHNhbXBsZVJhdGVNdWx0aXBsaWVyKVxuICAgICAgKTtcblxuICAgICAgLy8gUXVldWUgdG8gdGhlIGJ1ZmZlcmluZyBwbGF5ZXIuXG4gICAgICBwbGF5ZXIucHVzaCh1cHNhbXBsZWRNdWx0aUNoYW5uZWxBcnJheSk7XG4gICAgfVxuXG4gICAgYWJvcnRQcm9taXNlLmNhdGNoKCgpID0+IHBsYXllci5jYW5jZWxBbGwoKSk7XG5cbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWJvcnRlZCcpO1xuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UucmFjZShbYWJvcnRQcm9taXNlLCBwbGF5ZXIuZmx1c2goKV0pO1xuICB9IGZpbmFsbHkge1xuICAgIHF1ZXVlZEJ1ZmZlclNvdXJjZU5vZGVzLmZvckVhY2gobm9kZSA9PiBub2RlLnN0b3AoKSk7XG4gIH1cbn1cbiJdfQ==