"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _glamor = require("glamor");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _simpleUpdateIn = _interopRequireDefault(require("simple-update-in"));

var _createCustomEvent = _interopRequireDefault(require("../Utils/createCustomEvent"));

var _randomId = _interopRequireDefault(require("./randomId"));

var _useInternalMarkdownIt = _interopRequireDefault(require("../hooks/internal/useInternalMarkdownIt"));

var _useStyleOptions3 = _interopRequireDefault(require("../hooks/useStyleOptions"));

var _walkMarkdownTokens = _interopRequireDefault(require("./walkMarkdownTokens"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function replaceAnchorWithButton(markdownTokens) {
  return (0, _walkMarkdownTokens.default)(markdownTokens, function (markdownToken) {
    markdownToken = _objectSpread({}, markdownToken);

    switch (markdownToken.type) {
      case 'link_open':
        markdownToken.tag = 'button';
        markdownToken.attrs = [].concat(_toConsumableArray((0, _simpleUpdateIn.default)(markdownToken.attrs, [function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              name = _ref2[0],
              value = _ref2[1];

          return name === 'href' && value.startsWith('#');
        }], function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              value = _ref4[1];

          return ['data-markdown-href', value.substr(1)];
        })), [['type', 'button']]);
        break;

      case 'link_close':
        markdownToken.tag = 'button';
        break;

      default:
        break;
    }

    return markdownToken;
  });
}

var InlineMarkdown = function InlineMarkdown(_ref5) {
  var children = _ref5.children,
      onReference = _ref5.onReference,
      references = _ref5.references;

  if (typeof children !== 'string') {
    console.warn('botframework-webchat: "children" prop passed to <InlineMarkdown> must be of type string.');
    children = '';
  }

  var _useInternalMarkdownI = (0, _useInternalMarkdownIt.default)(),
      _useInternalMarkdownI2 = _slicedToArray(_useInternalMarkdownI, 1),
      markdownIt = _useInternalMarkdownI2[0];

  var _useStyleOptions = (0, _useStyleOptions3.default)(),
      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),
      accent = _useStyleOptions2[0].accent; // We inlined the style here because this style is:
  // 1. Internal to Web Chat
  // 2. Not customizable from developers (other than setting `styleOptions.accent`)


  var className = (0, _react.useMemo)(function () {
    return (0, _glamor.css)({
      '& button[data-markdown-href]': {
        appearance: 'none',
        backgroundColor: 'transparent',
        border: 0,
        color: accent,
        cursor: 'pointer',
        fontFamily: 'inherit',
        fontSize: 'inherit',
        padding: 0
      }
    }) + '';
  }, [accent]); // Markdown-It only support references in uppercase.

  references = references.map(function (reference) {
    return reference.toUpperCase();
  });

  var _references$reduce = references.reduce(function (_ref6, ref) {
    var hrefToRef = _ref6.hrefToRef,
        refToHref = _ref6.refToHref;
    var href = (0, _randomId.default)();
    return {
      hrefToRef: _objectSpread(_objectSpread({}, hrefToRef), {}, _defineProperty({}, href, ref)),
      refToHref: _objectSpread(_objectSpread({}, refToHref), {}, _defineProperty({}, ref, href))
    };
  }, {
    hrefToRef: {},
    refToHref: {}
  }),
      hrefToRef = _references$reduce.hrefToRef,
      refToHref = _references$reduce.refToHref;

  var html = (0, _react.useMemo)(function () {
    var tree = markdownIt.parseInline(children, {
      references: references.reduce( // (references, key) => ({ ...references, [key]: { href: `#${key}` } }),
      function (references, key) {
        return _objectSpread(_objectSpread({}, references), {}, _defineProperty({}, key, {
          href: "#".concat(refToHref[key])
        }));
      }, {})
    }); // Turn "<a href="#retry">Retry</a>" into "<button data-ref="retry" type="button">Retry</button>"

    var updatedTree = replaceAnchorWithButton(tree);
    return {
      __html: markdownIt.renderer.render(updatedTree)
    };
  }, [children, refToHref, markdownIt, references]);
  var handleClick = (0, _react.useCallback)(function (event) {
    event.stopPropagation();
    var href = event.target.getAttribute('data-markdown-href');
    href && onReference && onReference((0, _createCustomEvent.default)('reference', {
      data: hrefToRef[href]
    }));
  }, [hrefToRef, onReference]);
  return /*#__PURE__*/_react.default.createElement("span", {
    className: className,
    dangerouslySetInnerHTML: html,
    onClick: handleClick
  });
};

InlineMarkdown.defaultProps = {
  children: '',
  onReference: undefined,
  references: []
};
InlineMarkdown.propTypes = {
  children: _propTypes.default.string,
  onReference: _propTypes.default.func,
  references: _propTypes.default.arrayOf(_propTypes.default.string)
};
var _default = InlineMarkdown;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9VdGlscy9JbmxpbmVNYXJrZG93bi5qcyJdLCJuYW1lcyI6WyJyZXBsYWNlQW5jaG9yV2l0aEJ1dHRvbiIsIm1hcmtkb3duVG9rZW5zIiwibWFya2Rvd25Ub2tlbiIsInR5cGUiLCJ0YWciLCJhdHRycyIsIm5hbWUiLCJ2YWx1ZSIsInN0YXJ0c1dpdGgiLCJzdWJzdHIiLCJJbmxpbmVNYXJrZG93biIsImNoaWxkcmVuIiwib25SZWZlcmVuY2UiLCJyZWZlcmVuY2VzIiwiY29uc29sZSIsIndhcm4iLCJtYXJrZG93bkl0IiwiYWNjZW50IiwiY2xhc3NOYW1lIiwiYXBwZWFyYW5jZSIsImJhY2tncm91bmRDb2xvciIsImJvcmRlciIsImNvbG9yIiwiY3Vyc29yIiwiZm9udEZhbWlseSIsImZvbnRTaXplIiwicGFkZGluZyIsIm1hcCIsInJlZmVyZW5jZSIsInRvVXBwZXJDYXNlIiwicmVkdWNlIiwicmVmIiwiaHJlZlRvUmVmIiwicmVmVG9IcmVmIiwiaHJlZiIsImh0bWwiLCJ0cmVlIiwicGFyc2VJbmxpbmUiLCJrZXkiLCJ1cGRhdGVkVHJlZSIsIl9faHRtbCIsInJlbmRlcmVyIiwicmVuZGVyIiwiaGFuZGxlQ2xpY2siLCJldmVudCIsInN0b3BQcm9wYWdhdGlvbiIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsImRhdGEiLCJkZWZhdWx0UHJvcHMiLCJ1bmRlZmluZWQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJmdW5jIiwiYXJyYXlPZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxTQUFTQSx1QkFBVCxDQUFpQ0MsY0FBakMsRUFBaUQ7QUFDL0MsU0FBTyxpQ0FBbUJBLGNBQW5CLEVBQW1DLFVBQUFDLGFBQWEsRUFBSTtBQUN6REEsSUFBQUEsYUFBYSxxQkFBUUEsYUFBUixDQUFiOztBQUVBLFlBQVFBLGFBQWEsQ0FBQ0MsSUFBdEI7QUFDRSxXQUFLLFdBQUw7QUFDRUQsUUFBQUEsYUFBYSxDQUFDRSxHQUFkLEdBQW9CLFFBQXBCO0FBQ0FGLFFBQUFBLGFBQWEsQ0FBQ0csS0FBZCxnQ0FDSyw2QkFDREgsYUFBYSxDQUFDRyxLQURiLEVBRUQsQ0FBQztBQUFBO0FBQUEsY0FBRUMsSUFBRjtBQUFBLGNBQVFDLEtBQVI7O0FBQUEsaUJBQW1CRCxJQUFJLEtBQUssTUFBVCxJQUFtQkMsS0FBSyxDQUFDQyxVQUFOLENBQWlCLEdBQWpCLENBQXRDO0FBQUEsU0FBRCxDQUZDLEVBR0Q7QUFBQTtBQUFBLGNBQUlELEtBQUo7O0FBQUEsaUJBQWUsQ0FBQyxvQkFBRCxFQUF1QkEsS0FBSyxDQUFDRSxNQUFOLENBQWEsQ0FBYixDQUF2QixDQUFmO0FBQUEsU0FIQyxDQURMLElBTUUsQ0FBQyxNQUFELEVBQVMsUUFBVCxDQU5GO0FBUUE7O0FBRUYsV0FBSyxZQUFMO0FBQ0VQLFFBQUFBLGFBQWEsQ0FBQ0UsR0FBZCxHQUFvQixRQUFwQjtBQUNBOztBQUVGO0FBQ0U7QUFsQko7O0FBcUJBLFdBQU9GLGFBQVA7QUFDRCxHQXpCTSxDQUFQO0FBMEJEOztBQUVELElBQU1RLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsUUFBMkM7QUFBQSxNQUF4Q0MsUUFBd0MsU0FBeENBLFFBQXdDO0FBQUEsTUFBOUJDLFdBQThCLFNBQTlCQSxXQUE4QjtBQUFBLE1BQWpCQyxVQUFpQixTQUFqQkEsVUFBaUI7O0FBQ2hFLE1BQUksT0FBT0YsUUFBUCxLQUFvQixRQUF4QixFQUFrQztBQUNoQ0csSUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsMEZBQWI7QUFDQUosSUFBQUEsUUFBUSxHQUFHLEVBQVg7QUFDRDs7QUFKK0QsOEJBTTNDLHFDQU4yQztBQUFBO0FBQUEsTUFNekRLLFVBTnlEOztBQUFBLHlCQU8zQyxnQ0FQMkM7QUFBQTtBQUFBLE1BT3ZEQyxNQVB1RCx3QkFPdkRBLE1BUHVELEVBU2hFO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTUMsU0FBUyxHQUFHLG9CQUNoQjtBQUFBLFdBQ0UsaUJBQUk7QUFDRixzQ0FBZ0M7QUFDOUJDLFFBQUFBLFVBQVUsRUFBRSxNQURrQjtBQUU5QkMsUUFBQUEsZUFBZSxFQUFFLGFBRmE7QUFHOUJDLFFBQUFBLE1BQU0sRUFBRSxDQUhzQjtBQUk5QkMsUUFBQUEsS0FBSyxFQUFFTCxNQUp1QjtBQUs5Qk0sUUFBQUEsTUFBTSxFQUFFLFNBTHNCO0FBTTlCQyxRQUFBQSxVQUFVLEVBQUUsU0FOa0I7QUFPOUJDLFFBQUFBLFFBQVEsRUFBRSxTQVBvQjtBQVE5QkMsUUFBQUEsT0FBTyxFQUFFO0FBUnFCO0FBRDlCLEtBQUosSUFXSyxFQVpQO0FBQUEsR0FEZ0IsRUFjaEIsQ0FBQ1QsTUFBRCxDQWRnQixDQUFsQixDQVpnRSxDQTZCaEU7O0FBQ0FKLEVBQUFBLFVBQVUsR0FBR0EsVUFBVSxDQUFDYyxHQUFYLENBQWUsVUFBQUMsU0FBUztBQUFBLFdBQUlBLFNBQVMsQ0FBQ0MsV0FBVixFQUFKO0FBQUEsR0FBeEIsQ0FBYjs7QUE5QmdFLDJCQWdDL0JoQixVQUFVLENBQUNpQixNQUFYLENBQy9CLGlCQUEyQkMsR0FBM0IsRUFBbUM7QUFBQSxRQUFoQ0MsU0FBZ0MsU0FBaENBLFNBQWdDO0FBQUEsUUFBckJDLFNBQXFCLFNBQXJCQSxTQUFxQjtBQUNqQyxRQUFNQyxJQUFJLEdBQUcsd0JBQWI7QUFFQSxXQUFPO0FBQ0xGLE1BQUFBLFNBQVMsa0NBQU9BLFNBQVAsMkJBQW1CRSxJQUFuQixFQUEwQkgsR0FBMUIsRUFESjtBQUVMRSxNQUFBQSxTQUFTLGtDQUFPQSxTQUFQLDJCQUFtQkYsR0FBbkIsRUFBeUJHLElBQXpCO0FBRkosS0FBUDtBQUlELEdBUjhCLEVBUy9CO0FBQUVGLElBQUFBLFNBQVMsRUFBRSxFQUFiO0FBQWlCQyxJQUFBQSxTQUFTLEVBQUU7QUFBNUIsR0FUK0IsQ0FoQytCO0FBQUEsTUFnQ3hERCxTQWhDd0Qsc0JBZ0N4REEsU0FoQ3dEO0FBQUEsTUFnQzdDQyxTQWhDNkMsc0JBZ0M3Q0EsU0FoQzZDOztBQTRDaEUsTUFBTUUsSUFBSSxHQUFHLG9CQUFRLFlBQU07QUFDekIsUUFBTUMsSUFBSSxHQUFHcEIsVUFBVSxDQUFDcUIsV0FBWCxDQUF1QjFCLFFBQXZCLEVBQWlDO0FBQzVDRSxNQUFBQSxVQUFVLEVBQUVBLFVBQVUsQ0FBQ2lCLE1BQVgsRUFDVjtBQUNBLGdCQUFDakIsVUFBRCxFQUFheUIsR0FBYjtBQUFBLCtDQUEyQnpCLFVBQTNCLDJCQUF3Q3lCLEdBQXhDLEVBQThDO0FBQUVKLFVBQUFBLElBQUksYUFBTUQsU0FBUyxDQUFDSyxHQUFELENBQWY7QUFBTixTQUE5QztBQUFBLE9BRlUsRUFHVixFQUhVO0FBRGdDLEtBQWpDLENBQWIsQ0FEeUIsQ0FTekI7O0FBQ0EsUUFBTUMsV0FBVyxHQUFHdkMsdUJBQXVCLENBQUNvQyxJQUFELENBQTNDO0FBRUEsV0FBTztBQUFFSSxNQUFBQSxNQUFNLEVBQUV4QixVQUFVLENBQUN5QixRQUFYLENBQW9CQyxNQUFwQixDQUEyQkgsV0FBM0I7QUFBVixLQUFQO0FBQ0QsR0FiWSxFQWFWLENBQUM1QixRQUFELEVBQVdzQixTQUFYLEVBQXNCakIsVUFBdEIsRUFBa0NILFVBQWxDLENBYlUsQ0FBYjtBQWVBLE1BQU04QixXQUFXLEdBQUcsd0JBQ2xCLFVBQUFDLEtBQUssRUFBSTtBQUNQQSxJQUFBQSxLQUFLLENBQUNDLGVBQU47QUFFQSxRQUFNWCxJQUFJLEdBQUdVLEtBQUssQ0FBQ0UsTUFBTixDQUFhQyxZQUFiLENBQTBCLG9CQUExQixDQUFiO0FBRUFiLElBQUFBLElBQUksSUFBSXRCLFdBQVIsSUFBdUJBLFdBQVcsQ0FBQyxnQ0FBa0IsV0FBbEIsRUFBK0I7QUFBRW9DLE1BQUFBLElBQUksRUFBRWhCLFNBQVMsQ0FBQ0UsSUFBRDtBQUFqQixLQUEvQixDQUFELENBQWxDO0FBQ0QsR0FQaUIsRUFRbEIsQ0FBQ0YsU0FBRCxFQUFZcEIsV0FBWixDQVJrQixDQUFwQjtBQVdBLHNCQUFPO0FBQU0sSUFBQSxTQUFTLEVBQUVNLFNBQWpCO0FBQTRCLElBQUEsdUJBQXVCLEVBQUVpQixJQUFyRDtBQUEyRCxJQUFBLE9BQU8sRUFBRVE7QUFBcEUsSUFBUDtBQUNELENBdkVEOztBQXlFQWpDLGNBQWMsQ0FBQ3VDLFlBQWYsR0FBOEI7QUFDNUJ0QyxFQUFBQSxRQUFRLEVBQUUsRUFEa0I7QUFFNUJDLEVBQUFBLFdBQVcsRUFBRXNDLFNBRmU7QUFHNUJyQyxFQUFBQSxVQUFVLEVBQUU7QUFIZ0IsQ0FBOUI7QUFNQUgsY0FBYyxDQUFDeUMsU0FBZixHQUEyQjtBQUN6QnhDLEVBQUFBLFFBQVEsRUFBRXlDLG1CQUFVQyxNQURLO0FBRXpCekMsRUFBQUEsV0FBVyxFQUFFd0MsbUJBQVVFLElBRkU7QUFHekJ6QyxFQUFBQSxVQUFVLEVBQUV1QyxtQkFBVUcsT0FBVixDQUFrQkgsbUJBQVVDLE1BQTVCO0FBSGEsQ0FBM0I7ZUFNZTNDLGMiLCJzb3VyY2VSb290IjoiY29tcG9uZW50Oi8vLyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCByZWFjdC9uby1kYW5nZXI6IFwib2ZmXCIgKi9cblxuaW1wb3J0IHsgY3NzIH0gZnJvbSAnZ2xhbW9yJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXBkYXRlSW4gZnJvbSAnc2ltcGxlLXVwZGF0ZS1pbic7XG5cbmltcG9ydCBjcmVhdGVDdXN0b21FdmVudCBmcm9tICcuLi9VdGlscy9jcmVhdGVDdXN0b21FdmVudCc7XG5pbXBvcnQgcmFuZG9tSWQgZnJvbSAnLi9yYW5kb21JZCc7XG5pbXBvcnQgdXNlSW50ZXJuYWxNYXJrZG93bkl0IGZyb20gJy4uL2hvb2tzL2ludGVybmFsL3VzZUludGVybmFsTWFya2Rvd25JdCc7XG5pbXBvcnQgdXNlU3R5bGVPcHRpb25zIGZyb20gJy4uL2hvb2tzL3VzZVN0eWxlT3B0aW9ucyc7XG5pbXBvcnQgd2Fsa01hcmtkb3duVG9rZW5zIGZyb20gJy4vd2Fsa01hcmtkb3duVG9rZW5zJztcblxuZnVuY3Rpb24gcmVwbGFjZUFuY2hvcldpdGhCdXR0b24obWFya2Rvd25Ub2tlbnMpIHtcbiAgcmV0dXJuIHdhbGtNYXJrZG93blRva2VucyhtYXJrZG93blRva2VucywgbWFya2Rvd25Ub2tlbiA9PiB7XG4gICAgbWFya2Rvd25Ub2tlbiA9IHsgLi4ubWFya2Rvd25Ub2tlbiB9O1xuXG4gICAgc3dpdGNoIChtYXJrZG93blRva2VuLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2xpbmtfb3Blbic6XG4gICAgICAgIG1hcmtkb3duVG9rZW4udGFnID0gJ2J1dHRvbic7XG4gICAgICAgIG1hcmtkb3duVG9rZW4uYXR0cnMgPSBbXG4gICAgICAgICAgLi4udXBkYXRlSW4oXG4gICAgICAgICAgICBtYXJrZG93blRva2VuLmF0dHJzLFxuICAgICAgICAgICAgWyhbbmFtZSwgdmFsdWVdKSA9PiBuYW1lID09PSAnaHJlZicgJiYgdmFsdWUuc3RhcnRzV2l0aCgnIycpXSxcbiAgICAgICAgICAgIChbLCB2YWx1ZV0pID0+IFsnZGF0YS1tYXJrZG93bi1ocmVmJywgdmFsdWUuc3Vic3RyKDEpXVxuICAgICAgICAgICksXG4gICAgICAgICAgWyd0eXBlJywgJ2J1dHRvbiddXG4gICAgICAgIF07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdsaW5rX2Nsb3NlJzpcbiAgICAgICAgbWFya2Rvd25Ub2tlbi50YWcgPSAnYnV0dG9uJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrZG93blRva2VuO1xuICB9KTtcbn1cblxuY29uc3QgSW5saW5lTWFya2Rvd24gPSAoeyBjaGlsZHJlbiwgb25SZWZlcmVuY2UsIHJlZmVyZW5jZXMgfSkgPT4ge1xuICBpZiAodHlwZW9mIGNoaWxkcmVuICE9PSAnc3RyaW5nJykge1xuICAgIGNvbnNvbGUud2FybignYm90ZnJhbWV3b3JrLXdlYmNoYXQ6IFwiY2hpbGRyZW5cIiBwcm9wIHBhc3NlZCB0byA8SW5saW5lTWFya2Rvd24+IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuJyk7XG4gICAgY2hpbGRyZW4gPSAnJztcbiAgfVxuXG4gIGNvbnN0IFttYXJrZG93bkl0XSA9IHVzZUludGVybmFsTWFya2Rvd25JdCgpO1xuICBjb25zdCBbeyBhY2NlbnQgfV0gPSB1c2VTdHlsZU9wdGlvbnMoKTtcblxuICAvLyBXZSBpbmxpbmVkIHRoZSBzdHlsZSBoZXJlIGJlY2F1c2UgdGhpcyBzdHlsZSBpczpcbiAgLy8gMS4gSW50ZXJuYWwgdG8gV2ViIENoYXRcbiAgLy8gMi4gTm90IGN1c3RvbWl6YWJsZSBmcm9tIGRldmVsb3BlcnMgKG90aGVyIHRoYW4gc2V0dGluZyBgc3R5bGVPcHRpb25zLmFjY2VudGApXG4gIGNvbnN0IGNsYXNzTmFtZSA9IHVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIGNzcyh7XG4gICAgICAgICcmIGJ1dHRvbltkYXRhLW1hcmtkb3duLWhyZWZdJzoge1xuICAgICAgICAgIGFwcGVhcmFuY2U6ICdub25lJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAgIGNvbG9yOiBhY2NlbnQsXG4gICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgICAgICAgIGZvbnRTaXplOiAnaW5oZXJpdCcsXG4gICAgICAgICAgcGFkZGluZzogMFxuICAgICAgICB9XG4gICAgICB9KSArICcnLFxuICAgIFthY2NlbnRdXG4gICk7XG5cbiAgLy8gTWFya2Rvd24tSXQgb25seSBzdXBwb3J0IHJlZmVyZW5jZXMgaW4gdXBwZXJjYXNlLlxuICByZWZlcmVuY2VzID0gcmVmZXJlbmNlcy5tYXAocmVmZXJlbmNlID0+IHJlZmVyZW5jZS50b1VwcGVyQ2FzZSgpKTtcblxuICBjb25zdCB7IGhyZWZUb1JlZiwgcmVmVG9IcmVmIH0gPSByZWZlcmVuY2VzLnJlZHVjZShcbiAgICAoeyBocmVmVG9SZWYsIHJlZlRvSHJlZiB9LCByZWYpID0+IHtcbiAgICAgIGNvbnN0IGhyZWYgPSByYW5kb21JZCgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmVG9SZWY6IHsgLi4uaHJlZlRvUmVmLCBbaHJlZl06IHJlZiB9LFxuICAgICAgICByZWZUb0hyZWY6IHsgLi4ucmVmVG9IcmVmLCBbcmVmXTogaHJlZiB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgeyBocmVmVG9SZWY6IHt9LCByZWZUb0hyZWY6IHt9IH1cbiAgKTtcblxuICBjb25zdCBodG1sID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgdHJlZSA9IG1hcmtkb3duSXQucGFyc2VJbmxpbmUoY2hpbGRyZW4sIHtcbiAgICAgIHJlZmVyZW5jZXM6IHJlZmVyZW5jZXMucmVkdWNlKFxuICAgICAgICAvLyAocmVmZXJlbmNlcywga2V5KSA9PiAoeyAuLi5yZWZlcmVuY2VzLCBba2V5XTogeyBocmVmOiBgIyR7a2V5fWAgfSB9KSxcbiAgICAgICAgKHJlZmVyZW5jZXMsIGtleSkgPT4gKHsgLi4ucmVmZXJlbmNlcywgW2tleV06IHsgaHJlZjogYCMke3JlZlRvSHJlZltrZXldfWAgfSB9KSxcbiAgICAgICAge31cbiAgICAgIClcbiAgICB9KTtcblxuICAgIC8vIFR1cm4gXCI8YSBocmVmPVwiI3JldHJ5XCI+UmV0cnk8L2E+XCIgaW50byBcIjxidXR0b24gZGF0YS1yZWY9XCJyZXRyeVwiIHR5cGU9XCJidXR0b25cIj5SZXRyeTwvYnV0dG9uPlwiXG4gICAgY29uc3QgdXBkYXRlZFRyZWUgPSByZXBsYWNlQW5jaG9yV2l0aEJ1dHRvbih0cmVlKTtcblxuICAgIHJldHVybiB7IF9faHRtbDogbWFya2Rvd25JdC5yZW5kZXJlci5yZW5kZXIodXBkYXRlZFRyZWUpIH07XG4gIH0sIFtjaGlsZHJlbiwgcmVmVG9IcmVmLCBtYXJrZG93bkl0LCByZWZlcmVuY2VzXSk7XG5cbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSB1c2VDYWxsYmFjayhcbiAgICBldmVudCA9PiB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgY29uc3QgaHJlZiA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWFya2Rvd24taHJlZicpO1xuXG4gICAgICBocmVmICYmIG9uUmVmZXJlbmNlICYmIG9uUmVmZXJlbmNlKGNyZWF0ZUN1c3RvbUV2ZW50KCdyZWZlcmVuY2UnLCB7IGRhdGE6IGhyZWZUb1JlZltocmVmXSB9KSk7XG4gICAgfSxcbiAgICBbaHJlZlRvUmVmLCBvblJlZmVyZW5jZV1cbiAgKTtcblxuICByZXR1cm4gPHNwYW4gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXtodG1sfSBvbkNsaWNrPXtoYW5kbGVDbGlja30gLz47XG59O1xuXG5JbmxpbmVNYXJrZG93bi5kZWZhdWx0UHJvcHMgPSB7XG4gIGNoaWxkcmVuOiAnJyxcbiAgb25SZWZlcmVuY2U6IHVuZGVmaW5lZCxcbiAgcmVmZXJlbmNlczogW11cbn07XG5cbklubGluZU1hcmtkb3duLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5zdHJpbmcsXG4gIG9uUmVmZXJlbmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgcmVmZXJlbmNlczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZylcbn07XG5cbmV4cG9ydCBkZWZhdWx0IElubGluZU1hcmtkb3duO1xuIl19