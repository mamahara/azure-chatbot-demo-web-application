"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEarliestUpdateNotBefore = getEarliestUpdateNotBefore;
exports.default = void 0;

var _react = require("react");

var _simpleUpdateIn = _interopRequireDefault(require("simple-update-in"));

var _findMin = _interopRequireDefault(require("../Utils/findMin"));

var _useForceRender = _interopRequireDefault(require("./internal/useForceRender"));

var _useNotifications3 = _interopRequireDefault(require("./useNotifications"));

var _useStyleOptions3 = _interopRequireDefault(require("./useStyleOptions"));

var _useTimer = _interopRequireDefault(require("./internal/useTimer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function getEarliestUpdateNotBefore(notificationMap) {
  return (0, _findMin.default)(Object.values(notificationMap).filter(function (_ref) {
    var outOfDate = _ref.outOfDate;
    return outOfDate;
  }).map(function (_ref2) {
    var updateNotBefore = _ref2.updateNotBefore;
    return updateNotBefore;
  }));
}

function useDebouncedNotifications() {
  var now = Date.now();

  var _useStyleOptions = (0, _useStyleOptions3.default)(),
      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),
      notificationDebounceTimeout = _useStyleOptions2[0].notificationDebounceTimeout;

  var _useNotifications = (0, _useNotifications3.default)(),
      _useNotifications2 = _slicedToArray(_useNotifications, 1),
      notifications = _useNotifications2[0];

  var debouncedNotificationsRef = (0, _react.useRef)({});
  var forceRender = (0, _useForceRender.default)(); // Delete notifications or mark them to be deleted if debouncing.

  var _iterator = _createForOfIteratorHelper(Object.keys(debouncedNotificationsRef.current).filter(function (id) {
    return !(id in notifications);
  })),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var id = _step.value;
      debouncedNotificationsRef.current = (0, _simpleUpdateIn.default)(debouncedNotificationsRef.current, [id], function (debouncedNotification) {
        if (now < debouncedNotification.updateNotBefore) {
          // The update need to be postponed.
          return _objectSpread(_objectSpread({}, debouncedNotification), {}, {
            outOfDate: true
          });
        } // Otherwise, return undefined will remove it.

      });
    } // For any changes, update notifications or mark them to be updated if debouncing.

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var _loop = function _loop() {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        _Object$entries$_i$ = _Object$entries$_i[1],
        alt = _Object$entries$_i$.alt,
        data = _Object$entries$_i$.data,
        id = _Object$entries$_i$.id,
        level = _Object$entries$_i$.level,
        message = _Object$entries$_i$.message,
        timestamp = _Object$entries$_i$.timestamp;

    debouncedNotificationsRef.current = (0, _simpleUpdateIn.default)(debouncedNotificationsRef.current, [id], function (debouncedNotification) {
      if (debouncedNotification && alt === debouncedNotification.alt && Object.is(data, debouncedNotification.data) && level === debouncedNotification.level && message === debouncedNotification.message && timestamp === debouncedNotification.timestamp) {
        // If nothing changed, return as-is.
        return debouncedNotification;
      }

      if (debouncedNotification && now < debouncedNotification.updateNotBefore) {
        // The update need to be postponed.
        return _objectSpread(_objectSpread({}, debouncedNotification), {}, {
          outOfDate: true
        });
      } // Update the notification.


      return _objectSpread(_objectSpread({}, debouncedNotification), {}, {
        alt: alt,
        data: data,
        id: id,
        level: level,
        message: message,
        outOfDate: false,
        timestamp: timestamp,
        updateNotBefore: now + notificationDebounceTimeout
      });
    });
  };

  for (var _i2 = 0, _Object$entries = Object.entries(notifications); _i2 < _Object$entries.length; _i2++) {
    _loop();
  }

  (0, _useTimer.default)(getEarliestUpdateNotBefore(debouncedNotificationsRef.current), forceRender);
  return [debouncedNotificationsRef.current];
}

var _default = useDebouncedNotifications;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ob29rcy91c2VEZWJvdW5jZWROb3RpZmljYXRpb25zLmpzIl0sIm5hbWVzIjpbImdldEVhcmxpZXN0VXBkYXRlTm90QmVmb3JlIiwibm90aWZpY2F0aW9uTWFwIiwiT2JqZWN0IiwidmFsdWVzIiwiZmlsdGVyIiwib3V0T2ZEYXRlIiwibWFwIiwidXBkYXRlTm90QmVmb3JlIiwidXNlRGVib3VuY2VkTm90aWZpY2F0aW9ucyIsIm5vdyIsIkRhdGUiLCJub3RpZmljYXRpb25EZWJvdW5jZVRpbWVvdXQiLCJub3RpZmljYXRpb25zIiwiZGVib3VuY2VkTm90aWZpY2F0aW9uc1JlZiIsImZvcmNlUmVuZGVyIiwia2V5cyIsImN1cnJlbnQiLCJpZCIsImRlYm91bmNlZE5vdGlmaWNhdGlvbiIsImFsdCIsImRhdGEiLCJsZXZlbCIsIm1lc3NhZ2UiLCJ0aW1lc3RhbXAiLCJpcyIsImVudHJpZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLFNBQVNBLDBCQUFULENBQW9DQyxlQUFwQyxFQUFxRDtBQUNuRCxTQUFPLHNCQUNMQyxNQUFNLENBQUNDLE1BQVAsQ0FBY0YsZUFBZCxFQUNHRyxNQURILENBQ1U7QUFBQSxRQUFHQyxTQUFILFFBQUdBLFNBQUg7QUFBQSxXQUFtQkEsU0FBbkI7QUFBQSxHQURWLEVBRUdDLEdBRkgsQ0FFTztBQUFBLFFBQUdDLGVBQUgsU0FBR0EsZUFBSDtBQUFBLFdBQXlCQSxlQUF6QjtBQUFBLEdBRlAsQ0FESyxDQUFQO0FBS0Q7O0FBRUQsU0FBU0MseUJBQVQsR0FBcUM7QUFDbkMsTUFBTUMsR0FBRyxHQUFHQyxJQUFJLENBQUNELEdBQUwsRUFBWjs7QUFEbUMseUJBR08sZ0NBSFA7QUFBQTtBQUFBLE1BRzFCRSwyQkFIMEIsd0JBRzFCQSwyQkFIMEI7O0FBQUEsMEJBSVgsaUNBSlc7QUFBQTtBQUFB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b250ZW50IjpbImltcG9ydCB7IHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1cGRhdGVJbiBmcm9tICdzaW1wbGUtdXBkYXRlLWluJztcblxuaW1wb3J0IGZpbmRNaW4gZnJvbSAnLi4vVXRpbHMvZmluZE1pbic7XG5pbXBvcnQgdXNlRm9yY2VSZW5kZXIgZnJvbSAnLi9pbnRlcm5hbC91c2VGb3JjZVJlbmRlcic7XG5pbXBvcnQgdXNlTm90aWZpY2F0aW9ucyBmcm9tICcuL3VzZU5vdGlmaWNhdGlvbnMnO1xuaW1wb3J0IHVzZVN0eWxlT3B0aW9ucyBmcm9tICcuL3VzZVN0eWxlT3B0aW9ucyc7XG5pbXBvcnQgdXNlVGltZXIgZnJvbSAnLi9pbnRlcm5hbC91c2VUaW1lcic7XG5cbmZ1bmN0aW9uIGdldEVhcmxpZXN0VXBkYXRlTm90QmVmb3JlKG5vdGlmaWNhdGlvbk1hcCkge1xuICByZXR1cm4gZmluZE1pbihcbiAgICBPYmplY3QudmFsdWVzKG5vdGlmaWNhdGlvbk1hcClcbiAgICAgIC5maWx0ZXIoKHsgb3V0T2ZEYXRlIH0pID0+IG91dE9mRGF0ZSlcbiAgICAgIC5tYXAoKHsgdXBkYXRlTm90QmVmb3JlIH0pID0+IHVwZGF0ZU5vdEJlZm9yZSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXNlRGVib3VuY2VkTm90aWZpY2F0aW9ucygpIHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICBjb25zdCBbeyBub3RpZmljYXRpb25EZWJvdW5jZVRpbWVvdXQgfV0gPSB1c2VTdHlsZU9wdGlvbnMoKTtcbiAgY29uc3QgW25vdGlmaWNhdGlvbnNdID0gdXNlTm90aWZpY2F0aW9ucygpO1xuICBjb25zdCBkZWJvdW5jZWROb3RpZmljYXRpb25zUmVmID0gdXNlUmVmKHt9KTtcbiAgY29uc3QgZm9yY2VSZW5kZXIgPSB1c2VGb3JjZVJlbmRlcigpO1xuXG4gIC8vIERlbGV0ZSBub3RpZmljYXRpb25zIG9yIG1hcmsgdGhlbSB0byBiZSBkZWxldGVkIGlmIGRlYm91bmNpbmcuXG4gIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXMoZGVib3VuY2VkTm90aWZpY2F0aW9uc1JlZi5jdXJyZW50KS5maWx0ZXIoaWQgPT4gIShpZCBpbiBub3RpZmljYXRpb25zKSkpIHtcbiAgICBkZWJvdW5jZWROb3RpZmljYXRpb25zUmVmLmN1cnJlbnQgPSB1cGRhdGVJbihkZWJvdW5jZWROb3RpZmljYXRpb25zUmVmLmN1cnJlbnQsIFtpZF0sIGRlYm91bmNlZE5vdGlmaWNhdGlvbiA9PiB7XG4gICAgICBpZiAobm93IDwgZGVib3VuY2VkTm90aWZpY2F0aW9uLnVwZGF0ZU5vdEJlZm9yZSkge1xuICAgICAgICAvLyBUaGUgdXBkYXRlIG5lZWQgdG8gYmUgcG9zdHBvbmVkLlxuICAgICAgICByZXR1cm4geyAuLi5kZWJvdW5jZWROb3RpZmljYXRpb24sIG91dE9mRGF0ZTogdHJ1ZSB9O1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIHJldHVybiB1bmRlZmluZWQgd2lsbCByZW1vdmUgaXQuXG4gICAgfSk7XG4gIH1cblxuICAvLyBGb3IgYW55IGNoYW5nZXMsIHVwZGF0ZSBub3RpZmljYXRpb25zIG9yIG1hcmsgdGhlbSB0byBiZSB1cGRhdGVkIGlmIGRlYm91bmNpbmcuXG4gIGZvciAoY29uc3QgWywgeyBhbHQsIGRhdGEsIGlkLCBsZXZlbCwgbWVzc2FnZSwgdGltZXN0YW1wIH1dIG9mIE9iamVjdC5lbnRyaWVzKG5vdGlmaWNhdGlvbnMpKSB7XG4gICAgZGVib3VuY2VkTm90aWZpY2F0aW9uc1JlZi5jdXJyZW50ID0gdXBkYXRlSW4oZGVib3VuY2VkTm90aWZpY2F0aW9uc1JlZi5jdXJyZW50LCBbaWRdLCBkZWJvdW5jZWROb3RpZmljYXRpb24gPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBkZWJvdW5jZWROb3RpZmljYXRpb24gJiZcbiAgICAgICAgYWx0ID09PSBkZWJvdW5jZWROb3RpZmljYXRpb24uYWx0ICYmXG4gICAgICAgIE9iamVjdC5pcyhkYXRhLCBkZWJvdW5jZWROb3RpZmljYXRpb24uZGF0YSkgJiZcbiAgICAgICAgbGV2ZWwgPT09IGRlYm91bmNlZE5vdGlmaWNhdGlvbi5sZXZlbCAmJlxuICAgICAgICBtZXNzYWdlID09PSBkZWJvdW5jZWROb3RpZmljYXRpb24ubWVzc2FnZSAmJlxuICAgICAgICB0aW1lc3RhbXAgPT09IGRlYm91bmNlZE5vdGlmaWNhdGlvbi50aW1lc3RhbXBcbiAgICAgICkge1xuICAgICAgICAvLyBJZiBub3RoaW5nIGNoYW5nZWQsIHJldHVybiBhcy1pcy5cbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZE5vdGlmaWNhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlYm91bmNlZE5vdGlmaWNhdGlvbiAmJiBub3cgPCBkZWJvdW5jZWROb3RpZmljYXRpb24udXBkYXRlTm90QmVmb3JlKSB7XG4gICAgICAgIC8vIFRoZSB1cGRhdGUgbmVlZCB0byBiZSBwb3N0cG9uZWQuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZGVib3VuY2VkTm90aWZpY2F0aW9uLFxuICAgICAgICAgIG91dE9mRGF0ZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIG5vdGlmaWNhdGlvbi5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRlYm91bmNlZE5vdGlmaWNhdGlvbixcbiAgICAgICAgYWx0LFxuICAgICAgICBkYXRhLFxuICAgICAgICBpZCxcbiAgICAgICAgbGV2ZWwsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIG91dE9mRGF0ZTogZmFsc2UsXG4gICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgdXBkYXRlTm90QmVmb3JlOiBub3cgKyBub3RpZmljYXRpb25EZWJvdW5jZVRpbWVvdXRcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICB1c2VUaW1lcihnZXRFYXJsaWVzdFVwZGF0ZU5vdEJlZm9yZShkZWJvdW5jZWROb3RpZmljYXRpb25zUmVmLmN1cnJlbnQpLCBmb3JjZVJlbmRlcik7XG5cbiAgcmV0dXJuIFtkZWJvdW5jZWROb3RpZmljYXRpb25zUmVmLmN1cnJlbnRdO1xufVxuXG5leHBvcnQgZGVmYXVsdCB1c2VEZWJvdW5jZWROb3RpZmljYXRpb25zO1xuXG5leHBvcnQgeyBnZXRFYXJsaWVzdFVwZGF0ZU5vdEJlZm9yZSB9O1xuIl19