"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useObserveScrollPosition;

var _react = require("react");

var _reactScrollToBottom = require("react-scroll-to-bottom");

var _useGetTranscriptScrollableElement = _interopRequireDefault(require("./internal/useGetTranscriptScrollableElement"));

var _useTranscriptActivityElementsRef = _interopRequireDefault(require("./internal/useTranscriptActivityElementsRef"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function useObserveScrollPosition(observer, deps) {
  var getTranscriptScrollableElement = (0, _useGetTranscriptScrollableElement.default)();

  var _useTranscriptActivit = (0, _useTranscriptActivityElementsRef.default)(),
      _useTranscriptActivit2 = _slicedToArray(_useTranscriptActivit, 1),
      activityElementsRef = _useTranscriptActivit2[0];

  if (typeof observer !== 'function') {
    observer = undefined;
    console.warn('botframework-webchat: First argument passed to "useObserveScrollPosition" must be a function.');
  } else if (typeof deps !== 'undefined' && !Array.isArray(deps)) {
    console.warn('botframework-webchat: Second argument passed to "useObserveScrollPosition" must be an array if specified.');
  }

  var effectCallback = (0, _react.useCallback)(function (_ref) {
    var scrollTop = _ref.scrollTop;
    var scrollable = getTranscriptScrollableElement();

    var _scrollable$getClient = scrollable.getClientRects(),
        _scrollable$getClient2 = _slicedToArray(_scrollable$getClient, 1),
        _scrollable$getClient3 = _scrollable$getClient2[0];

    _scrollable$getClient3 = _scrollable$getClient3 === void 0 ? {} : _scrollable$getClient3;
    var offsetHeight = _scrollable$getClient3.height; // Find the activity just above scroll view bottom.
    // If the scroll view is already on top, get the first activity.

    var entry = scrollable.scrollTop ? _toConsumableArray(activityElementsRef.current).reverse().find(function (_ref2) {
      var element = _ref2.element;

      if (!element) {
        return false;
      }

      var _element$getClientRec = element.getClientRects(),
          _element$getClientRec2 = _slicedToArray(_element$getClientRec, 1),
          _element$getClientRec3 = _element$getClientRec2[0];

      _element$getClientRec3 = _element$getClientRec3 === void 0 ? {} : _element$getClientRec3;
      var y = _element$getClientRec3.y;
      return y < offsetHeight;
    }) : activityElementsRef.current[0];

    var _ref3 = entry || {},
        activityID = _ref3.activityID;

    observer && observer(_objectSpread(_objectSpread({}, activityID ? {
      activityID: activityID
    } : {}), {}, {
      scrollTop: scrollTop
    }));
  }, // This hook is very similar to useEffect, which internally use useCallback.
  // The "deps" is treated as the dependencies for the useCallback.

  /* eslint-disable-next-line react-hooks/exhaustive-deps */
  [activityElementsRef, getTranscriptScrollableElement].concat(_toConsumableArray(deps || [])));
  (0, _reactScrollToBottom.useObserveScrollPosition)(effectCallback);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ob29rcy91c2VPYnNlcnZlU2Nyb2xsUG9zaXRpb24uanMiXSwibmFtZXMiOlsidXNlT2JzZXJ2ZVNjcm9sbFBvc2l0aW9uIiwib2JzZXJ2ZXIiLCJkZXBzIiwiZ2V0VHJhbnNjcmlwdFNjcm9sbGFibGVFbGVtZW50IiwiYWN0aXZpdHlFbGVtZW50c1JlZiIsInVuZGVmaW5lZCIsImNvbnNvbGUiLCJ3YXJuIiwiQXJyYXkiLCJpc0FycmF5IiwiZWZmZWN0Q2FsbGJhY2siLCJzY3JvbGxUb3AiLCJzY3JvbGxhYmxlIiwiZ2V0Q2xpZW50UmVjdHMiLCJvZmZzZXRIZWlnaHQiLCJoZWlnaHQiLCJlbnRyeSIsImN1cnJlbnQiLCJyZXZlcnNlIiwiZmluZCIsImVsZW1lbnQiLCJ5IiwiYWN0aXZpdHlJRCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUVBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFZSxTQUFTQSx3QkFBVCxDQUFrQ0MsUUFBbEMsRUFBNENDLElBQTVDLEVBQWtEO0FBQy9ELE1BQU1DLDhCQUE4QixHQUFHLGlEQUF2Qzs7QUFEK0QsOEJBRWpDLGdEQUZpQztBQUFBO0FBQUEsTUFFeERDLG1CQUZ3RDs7QUFJL0QsTUFBSSxPQUFPSCxRQUFQLEtBQW9CLFVBQXhCLEVBQW9DO0FBQ2xDQSxJQUFBQSxRQUFRLEdBQUdJLFNBQVg7QUFDQUMsSUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsK0ZBQWI7QUFDRCxHQUhELE1BR08sSUFBSSxPQUFPTCxJQUFQLEtBQWdCLFdBQWhCLElBQStCLENBQUNNLEtBQUssQ0FBQ0MsT0FBTixDQUFjUCxJQUFkLENBQXBDLEVBQXlEO0FBQzlESSxJQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FDRSwyR0FERjtBQUdEOztBQUVELE1BQU1HLGNBQWMsR0FBRyx3QkFDckIsZ0JBQW1CO0FBQUEsUUFBaEJDLFNBQWdCLFFBQWhCQSxTQUFnQjtBQUNqQixRQUFNQyxVQUFVLEdBQUdULDhCQUE4QixFQUFqRDs7QUFEaUIsZ0NBRXVCUyxVQUFVLENBQUNDLGNBQVgsRUFGdkI7QUFBQTtBQUFBOztBQUFBLGlFQUVpQixFQUZqQjtBQUFBLFFBRUFDLFlBRkEsMEJBRVJDLE1BRlEsRUFJakI7QUFDQTs7QUFDQSxRQUFNQyxLQUFLLEdBQUdKLFVBQVUsQ0FBQ0QsU0FBWCxHQUNWLG1CQUFJUCxtQkFBbUIsQ0FBQ2EsT0FBeEIsRUFBaUNDLE9BQWpDLEdBQTJDQyxJQUEzQyxDQUFnRCxpQkFBaUI7QUFBQSxVQUFkQyxPQUFjLFNBQWRBLE9BQWM7O0FBQy9ELFVBQUksQ0FBQ0EsT0FBTCxFQUFjO0FBQ1osZUFBTyxLQUFQO0FBQ0Q7O0FBSDhELGtDQUsxQ0EsT0FBTyxDQUFDUCxjQUFSLEVBTDBDO0FBQUE7QUFBQTs7QUFBQSxtRUFLaEQsRUFMZ0Q7QUFBQSxVQUt0RFEsQ0FMc0QsMEJBS3REQSxDQUxzRDtBQU8vRCxhQUFPQSxDQUFDLEdBQUdQLFlBQVg7QUFDRCxLQVJELENBRFUsR0FVVlYsbUJBQW1CLENBQUNhLE9BQXBCLENBQTRCLENBQTVCLENBVko7O0FBTmlCLGdCQWtCTUQsS0FBSyxJQUFJLEVBbEJmO0FBQUEsUUFrQlRNLFVBbEJTLFNBa0JUQSxVQWxCUzs7QUFvQmpCckIsSUFBQUEsUUFBUSxJQUFJQSxRQUFRLGlDQUFPcUIsVUFBVSxHQUFHO0FBQUVBLE1BQUFBLFVBQVUsRUFBVkE7QUFBRixLQUFILEdBQW9CLEVBQXJDO0FBQTBDWCxNQUFBQSxTQUFTLEVBQVRBO0FBQTFDLE9BQXBCO0FBQ0QsR0F0Qm9CLEVBdUJyQjtBQUNBOztBQUNBO0FBekJxQixHQTBCcEJQLG1CQTFCb0IsRUEwQkNELDhCQTFCRCw0QkEwQnFDRCxJQUFJLElBQUksRUExQjdDLEdBQXZCO0FBNkJBLHFEQUF1Q1EsY0FBdkM7QUFDRCIsInNvdXJjZVJvb3QiOiJjb21wb25lbnQ6Ly8vIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VPYnNlcnZlU2Nyb2xsUG9zaXRpb24gYXMgdXNlU2Nyb2xsVG9Cb3R0b21PYnNlcnZlU2Nyb2xsUG9zaXRpb24gfSBmcm9tICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tJztcblxuaW1wb3J0IHVzZUdldFRyYW5zY3JpcHRTY3JvbGxhYmxlRWxlbWVudCBmcm9tICcuL2ludGVybmFsL3VzZUdldFRyYW5zY3JpcHRTY3JvbGxhYmxlRWxlbWVudCc7XG5pbXBvcnQgdXNlVHJhbnNjcmlwdEFjdGl2aXR5RWxlbWVudHNSZWYgZnJvbSAnLi9pbnRlcm5hbC91c2VUcmFuc2NyaXB0QWN0aXZpdHlFbGVtZW50c1JlZic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZU9ic2VydmVTY3JvbGxQb3NpdGlvbihvYnNlcnZlciwgZGVwcykge1xuICBjb25zdCBnZXRUcmFuc2NyaXB0U2Nyb2xsYWJsZUVsZW1lbnQgPSB1c2VHZXRUcmFuc2NyaXB0U2Nyb2xsYWJsZUVsZW1lbnQoKTtcbiAgY29uc3QgW2FjdGl2aXR5RWxlbWVudHNSZWZdID0gdXNlVHJhbnNjcmlwdEFjdGl2aXR5RWxlbWVudHNSZWYoKTtcblxuICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgY29uc29sZS53YXJuKCdib3RmcmFtZXdvcmstd2ViY2hhdDogRmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIFwidXNlT2JzZXJ2ZVNjcm9sbFBvc2l0aW9uXCIgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZXBzICE9PSAndW5kZWZpbmVkJyAmJiAhQXJyYXkuaXNBcnJheShkZXBzKSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdib3RmcmFtZXdvcmstd2ViY2hhdDogU2Vjb25kIGFyZ3VtZW50IHBhc3NlZCB0byBcInVzZU9ic2VydmVTY3JvbGxQb3NpdGlvblwiIG11c3QgYmUgYW4gYXJyYXkgaWYgc3BlY2lmaWVkLidcbiAgICApO1xuICB9XG5cbiAgY29uc3QgZWZmZWN0Q2FsbGJhY2sgPSB1c2VDYWxsYmFjayhcbiAgICAoeyBzY3JvbGxUb3AgfSkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsYWJsZSA9IGdldFRyYW5zY3JpcHRTY3JvbGxhYmxlRWxlbWVudCgpO1xuICAgICAgY29uc3QgW3sgaGVpZ2h0OiBvZmZzZXRIZWlnaHQgfSA9IHt9XSA9IHNjcm9sbGFibGUuZ2V0Q2xpZW50UmVjdHMoKTtcblxuICAgICAgLy8gRmluZCB0aGUgYWN0aXZpdHkganVzdCBhYm92ZSBzY3JvbGwgdmlldyBib3R0b20uXG4gICAgICAvLyBJZiB0aGUgc2Nyb2xsIHZpZXcgaXMgYWxyZWFkeSBvbiB0b3AsIGdldCB0aGUgZmlyc3QgYWN0aXZpdHkuXG4gICAgICBjb25zdCBlbnRyeSA9IHNjcm9sbGFibGUuc2Nyb2xsVG9wXG4gICAgICAgID8gWy4uLmFjdGl2aXR5RWxlbWVudHNSZWYuY3VycmVudF0ucmV2ZXJzZSgpLmZpbmQoKHsgZWxlbWVudCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBbeyB5IH0gPSB7fV0gPSBlbGVtZW50LmdldENsaWVudFJlY3RzKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB5IDwgb2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIH0pXG4gICAgICAgIDogYWN0aXZpdHlFbGVtZW50c1JlZi5jdXJyZW50WzBdO1xuXG4gICAgICBjb25zdCB7IGFjdGl2aXR5SUQgfSA9IGVudHJ5IHx8IHt9O1xuXG4gICAgICBvYnNlcnZlciAmJiBvYnNlcnZlcih7IC4uLihhY3Rpdml0eUlEID8geyBhY3Rpdml0eUlEIH0gOiB7fSksIHNjcm9sbFRvcCB9KTtcbiAgICB9LFxuICAgIC8vIFRoaXMgaG9vayBpcyB2ZXJ5IHNpbWlsYXIgdG8gdXNlRWZmZWN0LCB3aGljaCBpbnRlcm5hbGx5IHVzZSB1c2VDYWxsYmFjay5cbiAgICAvLyBUaGUgXCJkZXBzXCIgaXMgdHJlYXRlZCBhcyB0aGUgZGVwZW5kZW5jaWVzIGZvciB0aGUgdXNlQ2FsbGJhY2suXG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAqL1xuICAgIFthY3Rpdml0eUVsZW1lbnRzUmVmLCBnZXRUcmFuc2NyaXB0U2Nyb2xsYWJsZUVsZW1lbnQsIC4uLihkZXBzIHx8IFtdKV1cbiAgKTtcblxuICB1c2VTY3JvbGxUb0JvdHRvbU9ic2VydmVTY3JvbGxQb3NpdGlvbihlZmZlY3RDYWxsYmFjayk7XG59XG4iXX0=