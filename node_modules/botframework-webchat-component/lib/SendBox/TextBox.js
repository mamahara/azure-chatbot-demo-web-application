"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTextBoxSubmit = useTextBoxSubmit;
exports.useTextBoxValue = useTextBoxValue;
exports.connectSendTextBox = exports.default = void 0;

var _glamor = require("glamor");

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _TypeFocusSink = require("../Utils/TypeFocusSink");

var _AccessibleInputText = _interopRequireDefault(require("../Utils/AccessibleInputText"));

var _AccessibleTextArea = _interopRequireDefault(require("../Utils/AccessibleTextArea"));

var _connectToWebChat = _interopRequireDefault(require("../connectToWebChat"));

var _useDisabled3 = _interopRequireDefault(require("../hooks/useDisabled"));

var _useFocus = _interopRequireDefault(require("../hooks/useFocus"));

var _useLocalizer = _interopRequireDefault(require("../hooks/useLocalizer"));

var _useReplaceEmoticon = _interopRequireDefault(require("../hooks/internal/useReplaceEmoticon"));

var _useScrollToEnd = _interopRequireDefault(require("../hooks/useScrollToEnd"));

var _useSendBoxValue7 = _interopRequireDefault(require("../hooks/useSendBoxValue"));

var _useStopDictate = _interopRequireDefault(require("../hooks/useStopDictate"));

var _useStyleOptions3 = _interopRequireDefault(require("../hooks/useStyleOptions"));

var _useStyleSet3 = _interopRequireDefault(require("../hooks/useStyleSet"));

var _useSubmitSendBox = _interopRequireDefault(require("../hooks/useSubmitSendBox"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var ROOT_CSS = (0, _glamor.css)({
  '&.webchat__send-box-text-box': {
    display: 'flex',
    '& .webchat__send-box-text-box__input, & .webchat__send-box-text-box__text-area-box': {
      flex: 1
    }
  }
});

var connectSendTextBox = function connectSendTextBox() {
  for (var _len = arguments.length, selectors = new Array(_len), _key = 0; _key < _len; _key++) {
    selectors[_key] = arguments[_key];
  }

  return _connectToWebChat.default.apply(void 0, [function (_ref) {
    var disabled = _ref.disabled,
        focusSendBox = _ref.focusSendBox,
        language = _ref.language,
        scrollToEnd = _ref.scrollToEnd,
        sendBoxValue = _ref.sendBoxValue,
        setSendBox = _ref.setSendBox,
        stopDictate = _ref.stopDictate,
        submitSendBox = _ref.submitSendBox;
    return {
      disabled: disabled,
      language: language,
      onChange: function onChange(_ref2) {
        var value = _ref2.target.value;
        setSendBox(value);
        stopDictate();
      },
      onKeyPress: function onKeyPress(event) {
        var key = event.key,
            shiftKey = event.shiftKey;

        if (key === 'Enter' && !shiftKey) {
          event.preventDefault();

          if (sendBoxValue) {
            scrollToEnd();
            submitSendBox();
            focusSendBox();
          }
        }
      },
      onSubmit: function onSubmit(event) {
        event.preventDefault(); // Consider clearing the send box only after we received POST_ACTIVITY_PENDING
        // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box

        if (sendBoxValue) {
          scrollToEnd();
          submitSendBox();
        }
      },
      value: sendBoxValue
    };
  }].concat(selectors));
};

exports.connectSendTextBox = connectSendTextBox;

function useTextBoxSubmit() {
  var _useSendBoxValue = (0, _useSendBoxValue7.default)(),
      _useSendBoxValue2 = _slicedToArray(_useSendBoxValue, 1),
      sendBoxValue = _useSendBoxValue2[0];

  var focus = (0, _useFocus.default)();
  var scrollToEnd = (0, _useScrollToEnd.default)();
  var submitSendBox = (0, _useSubmitSendBox.default)();
  return (0, _react.useCallback)(function (setFocus) {
    if (sendBoxValue) {
      scrollToEnd();
      submitSendBox();

      if (setFocus) {
        if (setFocus === true) {
          console.warn("\"botframework-webchat: Passing \"true\" to \"useTextBoxSubmit\" is deprecated and will be removed on or after 2022-04-23. Please pass \"sendBox\" instead.\"");
          focus('sendBox');
        } else {
          focus(setFocus);
        }
      }
    }

    return !!sendBoxValue;
  }, [focus, scrollToEnd, sendBoxValue, submitSendBox]);
}

function useTextBoxValue() {
  var _useSendBoxValue3 = (0, _useSendBoxValue7.default)(),
      _useSendBoxValue4 = _slicedToArray(_useSendBoxValue3, 2),
      value = _useSendBoxValue4[0],
      setValue = _useSendBoxValue4[1];

  var replaceEmoticon = (0, _useReplaceEmoticon.default)();
  var stopDictate = (0, _useStopDictate.default)();
  var setter = (0, _react.useCallback)(function (nextValue) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        selectionEnd = _ref3.selectionEnd,
        selectionStart = _ref3.selectionStart;

    if (typeof nextValue !== 'string') {
      throw new Error('botframework-webchat: First argument passed to useTextBoxValue() must be a string.');
    } // Currently, we cannot detect whether the change is due to clipboard paste or pressing a key on the keyboard.
    // We should not change to emoji when the user is pasting text.
    // We would assume, for a single character addition, the user must be pressing a key.


    if (nextValue.length === value.length + 1) {
      var _replaceEmoticon = replaceEmoticon({
        selectionEnd: selectionEnd,
        selectionStart: selectionStart,
        value: nextValue
      }),
          nextSelectionEnd = _replaceEmoticon.selectionEnd,
          nextSelectionStart = _replaceEmoticon.selectionStart,
          nextValueWithEmoji = _replaceEmoticon.value;

      selectionEnd = nextSelectionEnd;
      selectionStart = nextSelectionStart;
      nextValue = nextValueWithEmoji;
    }

    setValue(nextValue);
    stopDictate();
    return {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart,
      value: nextValue
    };
  }, [replaceEmoticon, setValue, stopDictate, value]);
  return [value, setter];
}

var PREVENT_DEFAULT_HANDLER = function PREVENT_DEFAULT_HANDLER(event) {
  return event.preventDefault();
};

var TextBoxCore = /*#__PURE__*/(0, _react.forwardRef)(function (_ref4, forwardedRef) {
  var className = _ref4.className;

  var _useSendBoxValue5 = (0, _useSendBoxValue7.default)(),
      _useSendBoxValue6 = _slicedToArray(_useSendBoxValue5, 2),
      setSendBox = _useSendBoxValue6[1];

  var _useStyleSet = (0, _useStyleSet3.default)(),
      _useStyleSet2 = _slicedToArray(_useStyleSet, 1),
      _useStyleSet2$ = _useStyleSet2[0],
      sendBoxTextAreaStyleSet = _useStyleSet2$.sendBoxTextArea,
      sendBoxTextBoxStyleSet = _useStyleSet2$.sendBoxTextBox;

  var _useStyleOptions = (0, _useStyleOptions3.default)(),
      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),
      sendBoxTextWrap = _useStyleOptions2[0].sendBoxTextWrap;

  var _useDisabled = (0, _useDisabled3.default)(),
      _useDisabled2 = _slicedToArray(_useDisabled, 1),
      disabled = _useDisabled2[0];

  var _useTextBoxValue = useTextBoxValue(),
      _useTextBoxValue2 = _slicedToArray(_useTextBoxValue, 2),
      textBoxValue = _useTextBoxValue2[0],
      setTextBoxValue = _useTextBoxValue2[1];

  var inputElementRef = (0, _react.useRef)();
  var localize = (0, _useLocalizer.default)();
  var placeCheckpointOnChangeRef = (0, _react.useRef)(false);
  var prevInputStateRef = (0, _react.useRef)();
  var submitTextBox = useTextBoxSubmit();
  var undoStackRef = (0, _react.useRef)([]);
  var inputRefCallback = (0, _react.useCallback)(function (element) {
    if (typeof forwardedRef === 'function') {
      forwardedRef(element);
    } else if (forwardedRef) {
      forwardedRef.current = element;
    }

    inputElementRef.current = element;
  }, [forwardedRef, inputElementRef]);
  var sendBoxString = localize('TEXT_INPUT_ALT');
  var typeYourMessageString = localize('TEXT_INPUT_PLACEHOLDER');
  var rememberInputState = (0, _react.useCallback)(function () {
    var _inputElementRef$curr = inputElementRef.current,
        selectionEnd = _inputElementRef$curr.selectionEnd,
        selectionStart = _inputElementRef$curr.selectionStart,
        value = _inputElementRef$curr.value;
    prevInputStateRef.current = {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart,
      value: value
    };
  }, [inputElementRef, prevInputStateRef]); // This is for TypeFocusSink. When the focus in on the script, then starting press "a", without this line, it would cause errors.
  // We call rememberInputState() when "onFocus" event is fired, but since this is from TypeFocusSink, we are not able to receive "onFocus" event before it happen.

  (0, _react.useEffect)(rememberInputState, [rememberInputState]); // This is for moving the selection while setting the send box value.
  // If we only use setSendBox, we will need to wait for the next render cycle to get the value in, before we can set selectionEnd/Start.

  var setSelectionRangeAndValue = (0, _react.useCallback)(function (_ref5) {
    var selectionEnd = _ref5.selectionEnd,
        selectionStart = _ref5.selectionStart,
        value = _ref5.value;

    if (inputElementRef.current) {
      // We need to set the value, before selectionStart/selectionEnd.
      inputElementRef.current.value = value;
      inputElementRef.current.selectionStart = selectionStart;
      inputElementRef.current.selectionEnd = selectionEnd;
    }

    setSendBox(value);
  }, [inputElementRef, setSendBox]);
  var handleChange = (0, _react.useCallback)(function (event) {
    var _event$target = event.target,
        selectionEnd = _event$target.selectionEnd,
        selectionStart = _event$target.selectionStart,
        value = _event$target.value;

    if (placeCheckpointOnChangeRef.current) {
      undoStackRef.current.push(_objectSpread({}, prevInputStateRef.current));
      placeCheckpointOnChangeRef.current = false;
    }

    var nextInputState = setTextBoxValue(value, {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart
    }); // If an emoticon is converted to emoji, place another checkpoint.

    if (nextInputState.value !== value) {
      undoStackRef.current.push({
        selectionEnd: selectionEnd,
        selectionStart: selectionStart,
        value: value
      });
      placeCheckpointOnChangeRef.current = true;
      setSelectionRangeAndValue(nextInputState);
    }
  }, [placeCheckpointOnChangeRef, prevInputStateRef, setSelectionRangeAndValue, setTextBoxValue, undoStackRef]);
  var handleFocus = (0, _react.useCallback)(function () {
    rememberInputState();
    placeCheckpointOnChangeRef.current = true;
  }, [placeCheckpointOnChangeRef, rememberInputState]);
  var handleKeyDown = (0, _react.useCallback)(function (event) {
    var ctrlKey = event.ctrlKey,
        key = event.key,
        metaKey = event.metaKey;

    if ((ctrlKey || metaKey) && (key === 'Z' || key === 'z')) {
      event.preventDefault();
      var poppedInputState = undoStackRef.current.pop();

      if (poppedInputState) {
        prevInputStateRef.current = _objectSpread({}, poppedInputState);
      } else {
        prevInputStateRef.current = {
          selectionEnd: 0,
          selectionStart: 0,
          value: ''
        };
      }

      setSelectionRangeAndValue(prevInputStateRef.current);
    }
  }, [prevInputStateRef, setSelectionRangeAndValue, undoStackRef]);
  var handleKeyPress = (0, _react.useCallback)(function (event) {
    var key = event.key,
        shiftKey = event.shiftKey;

    if (key === 'Enter' && !shiftKey) {
      event.preventDefault(); // If text box is submitted, focus on the send box

      submitTextBox('sendBox'); // After submit, we will clear the undo stack.

      undoStackRef.current = [];
    }
  }, [submitTextBox, undoStackRef]);
  var handleSelect = (0, _react.useCallback)(function (_ref6) {
    var _ref6$target = _ref6.target,
        selectionEnd = _ref6$target.selectionEnd,
        selectionStart = _ref6$target.selectionStart,
        value = _ref6$target.value;

    if (value === prevInputStateRef.current.value) {
      // When caret move, we should push to undo stack on change.
      placeCheckpointOnChangeRef.current = true;
    }

    prevInputStateRef.current = {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart,
      value: value
    };
  }, [placeCheckpointOnChangeRef, prevInputStateRef]);
  var handleSubmit = (0, _react.useCallback)(function (event) {
    event.preventDefault(); // Consider clearing the send box only after we received POST_ACTIVITY_PENDING
    // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box

    submitTextBox(); // After submit, we will clear the undo stack.

    undoStackRef.current = [];
  }, [submitTextBox, undoStackRef]);
  return /*#__PURE__*/_react.default.createElement("form", {
    "aria-disabled": disabled,
    className: (0, _classnames.default)(ROOT_CSS + '', sendBoxTextAreaStyleSet + '', sendBoxTextBoxStyleSet + '', 'webchat__send-box-text-box', className + ''),
    onSubmit: disabled ? PREVENT_DEFAULT_HANDLER : handleSubmit
  }, !sendBoxTextWrap ? /*#__PURE__*/_react.default.createElement(_AccessibleInputText.default, {
    "aria-label": sendBoxString,
    className: "webchat__send-box-text-box__input",
    "data-id": "webchat-sendbox-input",
    disabled: disabled,
    enterkeyhint: "send" // The version of React we are using does not support "enterKeyHint" yet
    ,
    inputMode: "text",
    onChange: disabled ? undefined : handleChange,
    onFocus: disabled ? undefined : handleFocus,
    onKeyDown: disabled ? undefined : handleKeyDown,
    onKeyPress: disabled ? undefined : handleKeyPress,
    onSelect: disabled ? undefined : handleSelect,
    placeholder: typeYourMessageString,
    readOnly: disabled,
    ref: inputRefCallback,
    type: "text",
    value: textBoxValue
  }) : /*#__PURE__*/_react.default.createElement("div", {
    className: "webchat__send-box-text-box__text-area-box"
  }, /*#__PURE__*/_react.default.createElement(_AccessibleTextArea.default, {
    "aria-label": sendBoxString,
    className: "webchat__send-box-text-box__text-area",
    "data-id": "webchat-sendbox-input",
    disabled: disabled,
    enterkeyhint: "send" // The version of React we are using does not support "enterKeyHint" yet
    ,
    inputMode: "text",
    onChange: disabled ? undefined : handleChange,
    onFocus: disabled ? undefined : handleFocus,
    onKeyDown: disabled ? undefined : handleKeyDown,
    onKeyPress: disabled ? undefined : handleKeyPress,
    onSelect: disabled ? undefined : handleSelect,
    placeholder: typeYourMessageString,
    readOnly: disabled,
    ref: inputRefCallback,
    rows: "1",
    value: textBoxValue
  }), /*#__PURE__*/_react.default.createElement("div", {
    className: "webchat__send-box-text-box__text-area-doppelganger"
  }, textBoxValue + '\n')), disabled && /*#__PURE__*/_react.default.createElement("div", {
    className: "webchat__send-box-text-box__glass"
  }));
});
TextBoxCore.defaultProps = {
  className: ''
};
TextBoxCore.propTypes = {
  className: _propTypes.default.string
};

var TextBox = function TextBox(_ref7) {
  var className = _ref7.className;
  return (
    /*#__PURE__*/
    // For DOM node referenced by sendFocusRef, we are using a hack to focus on it.
    // By flipping readOnly attribute while setting focus, we can focus on text box without popping the virtual keyboard on mobile device.
    _react.default.createElement(_TypeFocusSink.Context.Consumer, null, function (_ref8) {
      var sendFocusRef = _ref8.sendFocusRef;
      return /*#__PURE__*/_react.default.createElement(TextBoxCore, {
        className: className,
        ref: sendFocusRef
      });
    })
  );
};

TextBox.defaultProps = {
  className: ''
};
TextBox.propTypes = {
  className: _propTypes.default.string
};
var _default = TextBox;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9TZW5kQm94L1RleHRCb3guanMiXSwibmFtZXMiOlsiUk9PVF9DU1MiLCJkaXNwbGF5IiwiZmxleCIsImNvbm5lY3RTZW5kVGV4dEJveCIsInNlbGVjdG9ycyIsImNvbm5lY3RUb1dlYkNoYXQiLCJkaXNhYmxlZCIsImZvY3VzU2VuZEJveCIsImxhbmd1YWdlIiwic2Nyb2xsVG9FbmQiLCJzZW5kQm94VmFsdWUiLCJzZXRTZW5kQm94Iiwic3RvcERpY3RhdGUiLCJzdWJtaXRTZW5kQm94Iiwib25DaGFuZ2UiLCJ2YWx1ZSIsInRhcmdldCIsIm9uS2V5UHJlc3MiLCJldmVudCIsImtleSIsInNoaWZ0S2V5IiwicHJldmVudERlZmF1bHQiLCJvblN1Ym1pdCIsInVzZVRleHRCb3hTdWJtaXQiLCJmb2N1cyIsInNldEZvY3VzIiwiY29uc29sZSIsIndhcm4iLCJ1c2VUZXh0Qm94VmFsdWUiLCJzZXRWYWx1ZSIsInJlcGxhY2VFbW90aWNvbiIsInNldHRlciIsIm5leHRWYWx1ZSIsInNlbGVjdGlvbkVuZCIsInNlbGVjdGlvblN0YXJ0IiwiRXJyb3IiLCJsZW5ndGgiLCJuZXh0U2VsZWN0aW9uRW5kIiwibmV4dFNlbGVjdGlvblN0YXJ0IiwibmV4dFZhbHVlV2l0aEVtb2ppIiwiUFJFVkVOVF9ERUZBVUxUX0hBTkRMRVIiLCJUZXh0Qm94Q29yZSIsImZvcndhcmRlZFJlZiIsImNsYXNzTmFtZSIsInNlbmRCb3hUZXh0QXJlYVN0eWxlU2V0Iiwic2VuZEJveFRleHRBcmVhIiwic2VuZEJveFRleHRCb3hTdHlsZVNldCIsInNlbmRCb3hUZXh0Qm94Iiwic2VuZEJveFRleHRXcmFwIiwidGV4dEJveFZhbHVlIiwic2V0VGV4dEJveFZhbHVlIiwiaW5wdXRFbGVtZW50UmVmIiwibG9jYWxpemUiLCJwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZiIsInByZXZJbnB1dFN0YXRlUmVmIiwic3VibWl0VGV4dEJveCIsInVuZG9TdGFja1JlZiIsImlucHV0UmVmQ2FsbGJhY2siLCJlbGVtZW50IiwiY3VycmVudCIsInNlbmRCb3hTdHJpbmciLCJ0eXBlWW91ck1lc3NhZ2VTdHJpbmciLCJyZW1lbWJlcklucHV0U3RhdGUiLCJzZXRTZWxlY3Rpb25SYW5nZUFuZFZhbHVlIiwiaGFuZGxlQ2hhbmdlIiwicHVzaCIsIm5leHRJbnB1dFN0YXRlIiwiaGFuZGxlRm9jdXMiLCJoYW5kbGVLZXlEb3duIiwiY3RybEtleSIsIm1ldGFLZXkiLCJwb3BwZWRJbnB1dFN0YXRlIiwicG9wIiwiaGFuZGxlS2V5UHJlc3MiLCJoYW5kbGVTZWxlY3QiLCJoYW5kbGVTdWJtaXQiLCJ1bmRlZmluZWQiLCJkZWZhdWx0UHJvcHMiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJUZXh0Qm94Iiwic2VuZEZvY3VzUmVmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLFFBQVEsR0FBRyxpQkFBSTtBQUNuQixrQ0FBZ0M7QUFDOUJDLElBQUFBLE9BQU8sRUFBRSxNQURxQjtBQUc5QiwwRkFBc0Y7QUFDcEZDLE1BQUFBLElBQUksRUFBRTtBQUQ4RTtBQUh4RDtBQURiLENBQUosQ0FBakI7O0FBVUEsSUFBTUMsa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFxQjtBQUFBLG9DQUFJQyxTQUFKO0FBQUlBLElBQUFBLFNBQUo7QUFBQTs7QUFBQSxTQUN6QkMseUNBQ0U7QUFBQSxRQUFHQyxRQUFILFFBQUdBLFFBQUg7QUFBQSxRQUFhQyxZQUFiLFFBQWFBLFlBQWI7QUFBQSxRQUEyQkMsUUFBM0IsUUFBMkJBLFFBQTNCO0FBQUEsUUFBcUNDLFdBQXJDLFFBQXFDQSxXQUFyQztBQUFBLFFBQWtEQyxZQUFsRCxRQUFrREEsWUFBbEQ7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RUFBQUEsU0FBUyxFQUFFO0FBRFUsQ0FBdkI7QUFJQXNDLE9BQU8sQ0FBQ0gsU0FBUixHQUFvQjtBQUNsQm5DLEVBQUFBLFNBQVMsRUFBRW9DLG1CQUFVQztBQURILENBQXBCO2VBSWVDLE8iLCJzb3VyY2VSb290IjoiY29tcG9uZW50Oi8vLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNzcyB9IGZyb20gJ2dsYW1vcic7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBDb250ZXh0IGFzIFR5cGVGb2N1c1NpbmtDb250ZXh0IH0gZnJvbSAnLi4vVXRpbHMvVHlwZUZvY3VzU2luayc7XG5pbXBvcnQgQWNjZXNzaWJsZUlucHV0VGV4dCBmcm9tICcuLi9VdGlscy9BY2Nlc3NpYmxlSW5wdXRUZXh0JztcbmltcG9ydCBBY2Nlc3NpYmxlVGV4dEFyZWEgZnJvbSAnLi4vVXRpbHMvQWNjZXNzaWJsZVRleHRBcmVhJztcbmltcG9ydCBjb25uZWN0VG9XZWJDaGF0IGZyb20gJy4uL2Nvbm5lY3RUb1dlYkNoYXQnO1xuaW1wb3J0IHVzZURpc2FibGVkIGZyb20gJy4uL2hvb2tzL3VzZURpc2FibGVkJztcbmltcG9ydCB1c2VGb2N1cyBmcm9tICcuLi9ob29rcy91c2VGb2N1cyc7XG5pbXBvcnQgdXNlTG9jYWxpemVyIGZyb20gJy4uL2hvb2tzL3VzZUxvY2FsaXplcic7XG5pbXBvcnQgdXNlUmVwbGFjZUVtb3RpY29uIGZyb20gJy4uL2hvb2tzL2ludGVybmFsL3VzZVJlcGxhY2VFbW90aWNvbic7XG5pbXBvcnQgdXNlU2Nyb2xsVG9FbmQgZnJvbSAnLi4vaG9va3MvdXNlU2Nyb2xsVG9FbmQnO1xuaW1wb3J0IHVzZVNlbmRCb3hWYWx1ZSBmcm9tICcuLi9ob29rcy91c2VTZW5kQm94VmFsdWUnO1xuaW1wb3J0IHVzZVN0b3BEaWN0YXRlIGZyb20gJy4uL2hvb2tzL3VzZVN0b3BEaWN0YXRlJztcbmltcG9ydCB1c2VTdHlsZU9wdGlvbnMgZnJvbSAnLi4vaG9va3MvdXNlU3R5bGVPcHRpb25zJztcbmltcG9ydCB1c2VTdHlsZVNldCBmcm9tICcuLi9ob29rcy91c2VTdHlsZVNldCc7XG5pbXBvcnQgdXNlU3VibWl0U2VuZEJveCBmcm9tICcuLi9ob29rcy91c2VTdWJtaXRTZW5kQm94JztcblxuY29uc3QgUk9PVF9DU1MgPSBjc3Moe1xuICAnJi53ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveCc6IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG5cbiAgICAnJiAud2ViY2hhdF9fc2VuZC1ib3gtdGV4dC1ib3hfX2lucHV0LCAmIC53ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveF9fdGV4dC1hcmVhLWJveCc6IHtcbiAgICAgIGZsZXg6IDFcbiAgICB9XG4gIH1cbn0pO1xuXG5jb25zdCBjb25uZWN0U2VuZFRleHRCb3ggPSAoLi4uc2VsZWN0b3JzKSA9PlxuICBjb25uZWN0VG9XZWJDaGF0KFxuICAgICh7IGRpc2FibGVkLCBmb2N1c1NlbmRCb3gsIGxhbmd1YWdlLCBzY3JvbGxUb0VuZCwgc2VuZEJveFZhbHVlLCBzZXRTZW5kQm94LCBzdG9wRGljdGF0ZSwgc3VibWl0U2VuZEJveCB9KSA9PiAoe1xuICAgICAgZGlzYWJsZWQsXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIG9uQ2hhbmdlOiAoeyB0YXJnZXQ6IHsgdmFsdWUgfSB9KSA9PiB7XG4gICAgICAgIHNldFNlbmRCb3godmFsdWUpO1xuICAgICAgICBzdG9wRGljdGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIG9uS2V5UHJlc3M6IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgeyBrZXksIHNoaWZ0S2V5IH0gPSBldmVudDtcblxuICAgICAgICBpZiAoa2V5ID09PSAnRW50ZXInICYmICFzaGlmdEtleSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoc2VuZEJveFZhbHVlKSB7XG4gICAgICAgICAgICBzY3JvbGxUb0VuZCgpO1xuICAgICAgICAgICAgc3VibWl0U2VuZEJveCgpO1xuICAgICAgICAgICAgZm9jdXNTZW5kQm94KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25TdWJtaXQ6IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBDb25zaWRlciBjbGVhcmluZyB0aGUgc2VuZCBib3ggb25seSBhZnRlciB3ZSByZWNlaXZlZCBQT1NUX0FDVElWSVRZX1BFTkRJTkdcbiAgICAgICAgLy8gRS5nLiBpZiB0aGUgY29ubmVjdGlvbiBpcyBiYWQsIHNlbmRpbmcgdGhlIG1lc3NhZ2UgZXNzZW50aWFsbHkgZG8gbm90aGluZyBidXQganVzdCBjbGVhcmluZyB0aGUgc2VuZCBib3hcblxuICAgICAgICBpZiAoc2VuZEJveFZhbHVlKSB7XG4gICAgICAgICAgc2Nyb2xsVG9FbmQoKTtcbiAgICAgICAgICBzdWJtaXRTZW5kQm94KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2YWx1ZTogc2VuZEJveFZhbHVlXG4gICAgfSksXG4gICAgLi4uc2VsZWN0b3JzXG4gICk7XG5cbmZ1bmN0aW9uIHVzZVRleHRCb3hTdWJtaXQoKSB7XG4gIGNvbnN0IFtzZW5kQm94VmFsdWVdID0gdXNlU2VuZEJveFZhbHVlKCk7XG4gIGNvbnN0IGZvY3VzID0gdXNlRm9jdXMoKTtcbiAgY29uc3Qgc2Nyb2xsVG9FbmQgPSB1c2VTY3JvbGxUb0VuZCgpO1xuICBjb25zdCBzdWJtaXRTZW5kQm94ID0gdXNlU3VibWl0U2VuZEJveCgpO1xuXG4gIHJldHVybiB1c2VDYWxsYmFjayhcbiAgICBzZXRGb2N1cyA9PiB7XG4gICAgICBpZiAoc2VuZEJveFZhbHVlKSB7XG4gICAgICAgIHNjcm9sbFRvRW5kKCk7XG4gICAgICAgIHN1Ym1pdFNlbmRCb3goKTtcblxuICAgICAgICBpZiAoc2V0Rm9jdXMpIHtcbiAgICAgICAgICBpZiAoc2V0Rm9jdXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgYFwiYm90ZnJhbWV3b3JrLXdlYmNoYXQ6IFBhc3NpbmcgXCJ0cnVlXCIgdG8gXCJ1c2VUZXh0Qm94U3VibWl0XCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIG9uIG9yIGFmdGVyIDIwMjItMDQtMjMuIFBsZWFzZSBwYXNzIFwic2VuZEJveFwiIGluc3RlYWQuXCJgXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmb2N1cygnc2VuZEJveCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb2N1cyhzZXRGb2N1cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhIXNlbmRCb3hWYWx1ZTtcbiAgICB9LFxuICAgIFtmb2N1cywgc2Nyb2xsVG9FbmQsIHNlbmRCb3hWYWx1ZSwgc3VibWl0U2VuZEJveF1cbiAgKTtcbn1cblxuZnVuY3Rpb24gdXNlVGV4dEJveFZhbHVlKCkge1xuICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IHVzZVNlbmRCb3hWYWx1ZSgpO1xuICBjb25zdCByZXBsYWNlRW1vdGljb24gPSB1c2VSZXBsYWNlRW1vdGljb24oKTtcbiAgY29uc3Qgc3RvcERpY3RhdGUgPSB1c2VTdG9wRGljdGF0ZSgpO1xuXG4gIGNvbnN0IHNldHRlciA9IHVzZUNhbGxiYWNrKFxuICAgIChuZXh0VmFsdWUsIHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCB9ID0ge30pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGZyYW1ld29yay13ZWJjaGF0OiBGaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gdXNlVGV4dEJveFZhbHVlKCkgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3VycmVudGx5LCB3ZSBjYW5ub3QgZGV0ZWN0IHdoZXRoZXIgdGhlIGNoYW5nZSBpcyBkdWUgdG8gY2xpcGJvYXJkIHBhc3RlIG9yIHByZXNzaW5nIGEga2V5IG9uIHRoZSBrZXlib2FyZC5cbiAgICAgIC8vIFdlIHNob3VsZCBub3QgY2hhbmdlIHRvIGVtb2ppIHdoZW4gdGhlIHVzZXIgaXMgcGFzdGluZyB0ZXh0LlxuICAgICAgLy8gV2Ugd291bGQgYXNzdW1lLCBmb3IgYSBzaW5nbGUgY2hhcmFjdGVyIGFkZGl0aW9uLCB0aGUgdXNlciBtdXN0IGJlIHByZXNzaW5nIGEga2V5LlxuICAgICAgaWYgKG5leHRWYWx1ZS5sZW5ndGggPT09IHZhbHVlLmxlbmd0aCArIDEpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNlbGVjdGlvbkVuZDogbmV4dFNlbGVjdGlvbkVuZCxcbiAgICAgICAgICBzZWxlY3Rpb25TdGFydDogbmV4dFNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIHZhbHVlOiBuZXh0VmFsdWVXaXRoRW1vamlcbiAgICAgICAgfSA9IHJlcGxhY2VFbW90aWNvbih7IHNlbGVjdGlvbkVuZCwgc2VsZWN0aW9uU3RhcnQsIHZhbHVlOiBuZXh0VmFsdWUgfSk7XG5cbiAgICAgICAgc2VsZWN0aW9uRW5kID0gbmV4dFNlbGVjdGlvbkVuZDtcbiAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSBuZXh0U2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIG5leHRWYWx1ZSA9IG5leHRWYWx1ZVdpdGhFbW9qaTtcbiAgICAgIH1cblxuICAgICAgc2V0VmFsdWUobmV4dFZhbHVlKTtcbiAgICAgIHN0b3BEaWN0YXRlKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdGlvbkVuZCxcbiAgICAgICAgc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgIHZhbHVlOiBuZXh0VmFsdWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBbcmVwbGFjZUVtb3RpY29uLCBzZXRWYWx1ZSwgc3RvcERpY3RhdGUsIHZhbHVlXVxuICApO1xuXG4gIHJldHVybiBbdmFsdWUsIHNldHRlcl07XG59XG5cbmNvbnN0IFBSRVZFTlRfREVGQVVMVF9IQU5ETEVSID0gZXZlbnQgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuY29uc3QgVGV4dEJveENvcmUgPSBmb3J3YXJkUmVmKCh7IGNsYXNzTmFtZSB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgWywgc2V0U2VuZEJveF0gPSB1c2VTZW5kQm94VmFsdWUoKTtcbiAgY29uc3QgW3sgc2VuZEJveFRleHRBcmVhOiBzZW5kQm94VGV4dEFyZWFTdHlsZVNldCwgc2VuZEJveFRleHRCb3g6IHNlbmRCb3hUZXh0Qm94U3R5bGVTZXQgfV0gPSB1c2VTdHlsZVNldCgpO1xuICBjb25zdCBbeyBzZW5kQm94VGV4dFdyYXAgfV0gPSB1c2VTdHlsZU9wdGlvbnMoKTtcbiAgY29uc3QgW2Rpc2FibGVkXSA9IHVzZURpc2FibGVkKCk7XG4gIGNvbnN0IFt0ZXh0Qm94VmFsdWUsIHNldFRleHRCb3hWYWx1ZV0gPSB1c2VUZXh0Qm94VmFsdWUoKTtcbiAgY29uc3QgaW5wdXRFbGVtZW50UmVmID0gdXNlUmVmKCk7XG4gIGNvbnN0IGxvY2FsaXplID0gdXNlTG9jYWxpemVyKCk7XG4gIGNvbnN0IHBsYWNlQ2hlY2twb2ludE9uQ2hhbmdlUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcHJldklucHV0U3RhdGVSZWYgPSB1c2VSZWYoKTtcbiAgY29uc3Qgc3VibWl0VGV4dEJveCA9IHVzZVRleHRCb3hTdWJtaXQoKTtcbiAgY29uc3QgdW5kb1N0YWNrUmVmID0gdXNlUmVmKFtdKTtcblxuICBjb25zdCBpbnB1dFJlZkNhbGxiYWNrID0gdXNlQ2FsbGJhY2soXG4gICAgZWxlbWVudCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGZvcndhcmRlZFJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3J3YXJkZWRSZWYoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmRlZFJlZikge1xuICAgICAgICBmb3J3YXJkZWRSZWYuY3VycmVudCA9IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlucHV0RWxlbWVudFJlZi5jdXJyZW50ID0gZWxlbWVudDtcbiAgICB9LFxuICAgIFtmb3J3YXJkZWRSZWYsIGlucHV0RWxlbWVudFJlZl1cbiAgKTtcblxuICBjb25zdCBzZW5kQm94U3RyaW5nID0gbG9jYWxpemUoJ1RFWFRfSU5QVVRfQUxUJyk7XG4gIGNvbnN0IHR5cGVZb3VyTWVzc2FnZVN0cmluZyA9IGxvY2FsaXplKCdURVhUX0lOUFVUX1BMQUNFSE9MREVSJyk7XG5cbiAgY29uc3QgcmVtZW1iZXJJbnB1dFN0YXRlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnQ6IHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCwgdmFsdWUgfVxuICAgIH0gPSBpbnB1dEVsZW1lbnRSZWY7XG5cbiAgICBwcmV2SW5wdXRTdGF0ZVJlZi5jdXJyZW50ID0geyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0LCB2YWx1ZSB9O1xuICB9LCBbaW5wdXRFbGVtZW50UmVmLCBwcmV2SW5wdXRTdGF0ZVJlZl0pO1xuXG4gIC8vIFRoaXMgaXMgZm9yIFR5cGVGb2N1c1NpbmsuIFdoZW4gdGhlIGZvY3VzIGluIG9uIHRoZSBzY3JpcHQsIHRoZW4gc3RhcnRpbmcgcHJlc3MgXCJhXCIsIHdpdGhvdXQgdGhpcyBsaW5lLCBpdCB3b3VsZCBjYXVzZSBlcnJvcnMuXG4gIC8vIFdlIGNhbGwgcmVtZW1iZXJJbnB1dFN0YXRlKCkgd2hlbiBcIm9uRm9jdXNcIiBldmVudCBpcyBmaXJlZCwgYnV0IHNpbmNlIHRoaXMgaXMgZnJvbSBUeXBlRm9jdXNTaW5rLCB3ZSBhcmUgbm90IGFibGUgdG8gcmVjZWl2ZSBcIm9uRm9jdXNcIiBldmVudCBiZWZvcmUgaXQgaGFwcGVuLlxuICB1c2VFZmZlY3QocmVtZW1iZXJJbnB1dFN0YXRlLCBbcmVtZW1iZXJJbnB1dFN0YXRlXSk7XG5cbiAgLy8gVGhpcyBpcyBmb3IgbW92aW5nIHRoZSBzZWxlY3Rpb24gd2hpbGUgc2V0dGluZyB0aGUgc2VuZCBib3ggdmFsdWUuXG4gIC8vIElmIHdlIG9ubHkgdXNlIHNldFNlbmRCb3gsIHdlIHdpbGwgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCByZW5kZXIgY3ljbGUgdG8gZ2V0IHRoZSB2YWx1ZSBpbiwgYmVmb3JlIHdlIGNhbiBzZXQgc2VsZWN0aW9uRW5kL1N0YXJ0LlxuICBjb25zdCBzZXRTZWxlY3Rpb25SYW5nZUFuZFZhbHVlID0gdXNlQ2FsbGJhY2soXG4gICAgKHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCwgdmFsdWUgfSkgPT4ge1xuICAgICAgaWYgKGlucHV0RWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc2V0IHRoZSB2YWx1ZSwgYmVmb3JlIHNlbGVjdGlvblN0YXJ0L3NlbGVjdGlvbkVuZC5cbiAgICAgICAgaW5wdXRFbGVtZW50UmVmLmN1cnJlbnQudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBpbnB1dEVsZW1lbnRSZWYuY3VycmVudC5zZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBpbnB1dEVsZW1lbnRSZWYuY3VycmVudC5zZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb25FbmQ7XG4gICAgICB9XG5cbiAgICAgIHNldFNlbmRCb3godmFsdWUpO1xuICAgIH0sXG4gICAgW2lucHV0RWxlbWVudFJlZiwgc2V0U2VuZEJveF1cbiAgKTtcblxuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRhcmdldDogeyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0LCB2YWx1ZSB9XG4gICAgICB9ID0gZXZlbnQ7XG5cbiAgICAgIGlmIChwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHVuZG9TdGFja1JlZi5jdXJyZW50LnB1c2goeyAuLi5wcmV2SW5wdXRTdGF0ZVJlZi5jdXJyZW50IH0pO1xuXG4gICAgICAgIHBsYWNlQ2hlY2twb2ludE9uQ2hhbmdlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV4dElucHV0U3RhdGUgPSBzZXRUZXh0Qm94VmFsdWUodmFsdWUsIHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCB9KTtcblxuICAgICAgLy8gSWYgYW4gZW1vdGljb24gaXMgY29udmVydGVkIHRvIGVtb2ppLCBwbGFjZSBhbm90aGVyIGNoZWNrcG9pbnQuXG4gICAgICBpZiAobmV4dElucHV0U3RhdGUudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHVuZG9TdGFja1JlZi5jdXJyZW50LnB1c2goeyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0LCB2YWx1ZSB9KTtcblxuICAgICAgICBwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZi5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgICBzZXRTZWxlY3Rpb25SYW5nZUFuZFZhbHVlKG5leHRJbnB1dFN0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZiwgcHJldklucHV0U3RhdGVSZWYsIHNldFNlbGVjdGlvblJhbmdlQW5kVmFsdWUsIHNldFRleHRCb3hWYWx1ZSwgdW5kb1N0YWNrUmVmXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUZvY3VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJlbWVtYmVySW5wdXRTdGF0ZSgpO1xuXG4gICAgcGxhY2VDaGVja3BvaW50T25DaGFuZ2VSZWYuY3VycmVudCA9IHRydWU7XG4gIH0sIFtwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZiwgcmVtZW1iZXJJbnB1dFN0YXRlXSk7XG5cbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IHVzZUNhbGxiYWNrKFxuICAgIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHsgY3RybEtleSwga2V5LCBtZXRhS2V5IH0gPSBldmVudDtcblxuICAgICAgaWYgKChjdHJsS2V5IHx8IG1ldGFLZXkpICYmIChrZXkgPT09ICdaJyB8fCBrZXkgPT09ICd6JykpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBjb25zdCBwb3BwZWRJbnB1dFN0YXRlID0gdW5kb1N0YWNrUmVmLmN1cnJlbnQucG9wKCk7XG5cbiAgICAgICAgaWYgKHBvcHBlZElucHV0U3RhdGUpIHtcbiAgICAgICAgICBwcmV2SW5wdXRTdGF0ZVJlZi5jdXJyZW50ID0geyAuLi5wb3BwZWRJbnB1dFN0YXRlIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldklucHV0U3RhdGVSZWYuY3VycmVudCA9IHsgc2VsZWN0aW9uRW5kOiAwLCBzZWxlY3Rpb25TdGFydDogMCwgdmFsdWU6ICcnIH07XG4gICAgICAgIH1cblxuICAgICAgICBzZXRTZWxlY3Rpb25SYW5nZUFuZFZhbHVlKHByZXZJbnB1dFN0YXRlUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3ByZXZJbnB1dFN0YXRlUmVmLCBzZXRTZWxlY3Rpb25SYW5nZUFuZFZhbHVlLCB1bmRvU3RhY2tSZWZdXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlS2V5UHJlc3MgPSB1c2VDYWxsYmFjayhcbiAgICBldmVudCA9PiB7XG4gICAgICBjb25zdCB7IGtleSwgc2hpZnRLZXkgfSA9IGV2ZW50O1xuXG4gICAgICBpZiAoa2V5ID09PSAnRW50ZXInICYmICFzaGlmdEtleSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIElmIHRleHQgYm94IGlzIHN1Ym1pdHRlZCwgZm9jdXMgb24gdGhlIHNlbmQgYm94XG4gICAgICAgIHN1Ym1pdFRleHRCb3goJ3NlbmRCb3gnKTtcblxuICAgICAgICAvLyBBZnRlciBzdWJtaXQsIHdlIHdpbGwgY2xlYXIgdGhlIHVuZG8gc3RhY2suXG4gICAgICAgIHVuZG9TdGFja1JlZi5jdXJyZW50ID0gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBbc3VibWl0VGV4dEJveCwgdW5kb1N0YWNrUmVmXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZVNlbGVjdCA9IHVzZUNhbGxiYWNrKFxuICAgICh7IHRhcmdldDogeyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0LCB2YWx1ZSB9IH0pID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gcHJldklucHV0U3RhdGVSZWYuY3VycmVudC52YWx1ZSkge1xuICAgICAgICAvLyBXaGVuIGNhcmV0IG1vdmUsIHdlIHNob3VsZCBwdXNoIHRvIHVuZG8gc3RhY2sgb24gY2hhbmdlLlxuICAgICAgICBwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcHJldklucHV0U3RhdGVSZWYuY3VycmVudCA9IHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCwgdmFsdWUgfTtcbiAgICB9LFxuICAgIFtwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZiwgcHJldklucHV0U3RhdGVSZWZdXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgLy8gQ29uc2lkZXIgY2xlYXJpbmcgdGhlIHNlbmQgYm94IG9ubHkgYWZ0ZXIgd2UgcmVjZWl2ZWQgUE9TVF9BQ1RJVklUWV9QRU5ESU5HXG4gICAgICAvLyBFLmcuIGlmIHRoZSBjb25uZWN0aW9uIGlzIGJhZCwgc2VuZGluZyB0aGUgbWVzc2FnZSBlc3NlbnRpYWxseSBkbyBub3RoaW5nIGJ1dCBqdXN0IGNsZWFyaW5nIHRoZSBzZW5kIGJveFxuICAgICAgc3VibWl0VGV4dEJveCgpO1xuXG4gICAgICAvLyBBZnRlciBzdWJtaXQsIHdlIHdpbGwgY2xlYXIgdGhlIHVuZG8gc3RhY2suXG4gICAgICB1bmRvU3RhY2tSZWYuY3VycmVudCA9IFtdO1xuICAgIH0sXG4gICAgW3N1Ym1pdFRleHRCb3gsIHVuZG9TdGFja1JlZl1cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxmb3JtXG4gICAgICBhcmlhLWRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgUk9PVF9DU1MgKyAnJyxcbiAgICAgICAgc2VuZEJveFRleHRBcmVhU3R5bGVTZXQgKyAnJyxcbiAgICAgICAgc2VuZEJveFRleHRCb3hTdHlsZVNldCArICcnLFxuICAgICAgICAnd2ViY2hhdF9fc2VuZC1ib3gtdGV4dC1ib3gnLFxuICAgICAgICBjbGFzc05hbWUgKyAnJ1xuICAgICAgKX1cbiAgICAgIG9uU3VibWl0PXtkaXNhYmxlZCA/IFBSRVZFTlRfREVGQVVMVF9IQU5ETEVSIDogaGFuZGxlU3VibWl0fVxuICAgID5cbiAgICAgIHshc2VuZEJveFRleHRXcmFwID8gKFxuICAgICAgICA8QWNjZXNzaWJsZUlucHV0VGV4dFxuICAgICAgICAgIGFyaWEtbGFiZWw9e3NlbmRCb3hTdHJpbmd9XG4gICAgICAgICAgY2xhc3NOYW1lPVwid2ViY2hhdF9fc2VuZC1ib3gtdGV4dC1ib3hfX2lucHV0XCJcbiAgICAgICAgICBkYXRhLWlkPVwid2ViY2hhdC1zZW5kYm94LWlucHV0XCJcbiAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgZW50ZXJrZXloaW50PVwic2VuZFwiIC8vIFRoZSB2ZXJzaW9uIG9mIFJlYWN0IHdlIGFyZSB1c2luZyBkb2VzIG5vdCBzdXBwb3J0IFwiZW50ZXJLZXlIaW50XCIgeWV0XG4gICAgICAgICAgaW5wdXRNb2RlPVwidGV4dFwiXG4gICAgICAgICAgb25DaGFuZ2U9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIG9uRm9jdXM9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlRm9jdXN9XG4gICAgICAgICAgb25LZXlEb3duPXtkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGhhbmRsZUtleURvd259XG4gICAgICAgICAgb25LZXlQcmVzcz17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVLZXlQcmVzc31cbiAgICAgICAgICBvblNlbGVjdD17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVTZWxlY3R9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9e3R5cGVZb3VyTWVzc2FnZVN0cmluZ31cbiAgICAgICAgICByZWFkT25seT17ZGlzYWJsZWR9XG4gICAgICAgICAgcmVmPXtpbnB1dFJlZkNhbGxiYWNrfVxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICB2YWx1ZT17dGV4dEJveFZhbHVlfVxuICAgICAgICAvPlxuICAgICAgKSA6IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveF9fdGV4dC1hcmVhLWJveFwiPlxuICAgICAgICAgIDxBY2Nlc3NpYmxlVGV4dEFyZWFcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e3NlbmRCb3hTdHJpbmd9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ3ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveF9fdGV4dC1hcmVhXCJcbiAgICAgICAgICAgIGRhdGEtaWQ9XCJ3ZWJjaGF0LXNlbmRib3gtaW5wdXRcIlxuICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgZW50ZXJrZXloaW50PVwic2VuZFwiIC8vIFRoZSB2ZXJzaW9uIG9mIFJlYWN0IHdlIGFyZSB1c2luZyBkb2VzIG5vdCBzdXBwb3J0IFwiZW50ZXJLZXlIaW50XCIgeWV0XG4gICAgICAgICAgICBpbnB1dE1vZGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXtkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGhhbmRsZUNoYW5nZX1cbiAgICAgICAgICAgIG9uRm9jdXM9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlRm9jdXN9XG4gICAgICAgICAgICBvbktleURvd249e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlS2V5RG93bn1cbiAgICAgICAgICAgIG9uS2V5UHJlc3M9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlS2V5UHJlc3N9XG4gICAgICAgICAgICBvblNlbGVjdD17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVTZWxlY3R9XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj17dHlwZVlvdXJNZXNzYWdlU3RyaW5nfVxuICAgICAgICAgICAgcmVhZE9ubHk9e2Rpc2FibGVkfVxuICAgICAgICAgICAgcmVmPXtpbnB1dFJlZkNhbGxiYWNrfVxuICAgICAgICAgICAgcm93cz1cIjFcIlxuICAgICAgICAgICAgdmFsdWU9e3RleHRCb3hWYWx1ZX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2ViY2hhdF9fc2VuZC1ib3gtdGV4dC1ib3hfX3RleHQtYXJlYS1kb3BwZWxnYW5nZXJcIj57dGV4dEJveFZhbHVlICsgJ1xcbid9PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICAgIHtkaXNhYmxlZCAmJiA8ZGl2IGNsYXNzTmFtZT1cIndlYmNoYXRfX3NlbmQtYm94LXRleHQtYm94X19nbGFzc1wiIC8+fVxuICAgIDwvZm9ybT5cbiAgKTtcbn0pO1xuXG5UZXh0Qm94Q29yZS5kZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogJydcbn07XG5cblRleHRCb3hDb3JlLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5jb25zdCBUZXh0Qm94ID0gKHsgY2xhc3NOYW1lIH0pID0+IChcbiAgLy8gRm9yIERPTSBub2RlIHJlZmVyZW5jZWQgYnkgc2VuZEZvY3VzUmVmLCB3ZSBhcmUgdXNpbmcgYSBoYWNrIHRvIGZvY3VzIG9uIGl0LlxuICAvLyBCeSBmbGlwcGluZyByZWFkT25seSBhdHRyaWJ1dGUgd2hpbGUgc2V0dGluZyBmb2N1cywgd2UgY2FuIGZvY3VzIG9uIHRleHQgYm94IHdpdGhvdXQgcG9wcGluZyB0aGUgdmlydHVhbCBrZXlib2FyZCBvbiBtb2JpbGUgZGV2aWNlLlxuICA8VHlwZUZvY3VzU2lua0NvbnRleHQuQ29uc3VtZXI+XG4gICAgeyh7IHNlbmRGb2N1c1JlZiB9KSA9PiA8VGV4dEJveENvcmUgY2xhc3NOYW1lPXtjbGFzc05hbWV9IHJlZj17c2VuZEZvY3VzUmVmfSAvPn1cbiAgPC9UeXBlRm9jdXNTaW5rQ29udGV4dC5Db25zdW1lcj5cbik7XG5cblRleHRCb3guZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWU6ICcnXG59O1xuXG5UZXh0Qm94LnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0Qm94O1xuXG5leHBvcnQgeyBjb25uZWN0U2VuZFRleHRCb3gsIHVzZVRleHRCb3hTdWJtaXQsIHVzZVRleHRCb3hWYWx1ZSB9O1xuIl19