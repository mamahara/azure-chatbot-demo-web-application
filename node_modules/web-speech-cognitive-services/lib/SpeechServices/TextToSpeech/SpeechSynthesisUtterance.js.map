{"version":3,"sources":["../../../src/SpeechServices/TextToSpeech/SpeechSynthesisUtterance.js"],"names":["asyncDecodeAudioData","audioContext","arrayBuffer","Promise","resolve","reject","promise","decodeAudioData","then","playDecoded","audioBuffer","source","audioContextClosed","EventAsPromise","sourceEnded","unsubscribe","state","target","eventListener","buffer","onended","connect","destination","start","race","upcoming","err","SpeechSynthesisUtterance","text","_lang","_pitch","_rate","_voice","_volume","onboundary","onend","onerror","onmark","onpause","onresume","onstart","deploymentId","fetchCredentials","outputFormat","arrayBufferPromise","lang","window","navigator","language","pitch","rate","voice","voiceURI","volume","catch","dispatchEvent","SpeechSynthesisEvent","createBufferSource","_playingSource","ErrorEvent","error","message","stack","stop","value","EventTarget","prototype"],"mappings":"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","sourcesContent":["/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\n\nimport { defineEventAttribute, EventTarget } from 'event-target-shim-es5';\nimport EventAsPromise from 'event-as-promise';\n\nimport fetchSpeechData from './fetchSpeechData';\nimport SpeechSynthesisEvent from './SpeechSynthesisEvent';\nimport subscribeEvent from './subscribeEvent';\n\nfunction asyncDecodeAudioData(audioContext, arrayBuffer) {\n  return new Promise((resolve, reject) => {\n    const promise = audioContext.decodeAudioData(arrayBuffer, resolve, reject);\n\n    // Newer implementation of \"decodeAudioData\" will return a Promise\n    promise && typeof promise.then === 'function' && resolve(promise);\n  });\n}\n\nfunction playDecoded(audioContext, audioBuffer, source) {\n  return new Promise((resolve, reject) => {\n    const audioContextClosed = new EventAsPromise();\n    const sourceEnded = new EventAsPromise();\n    const unsubscribe = subscribeEvent(\n      audioContext,\n      'statechange',\n      ({ target: { state } }) => state === 'closed' && audioContextClosed.eventListener()\n    );\n\n    try {\n      source.buffer = audioBuffer;\n      // \"ended\" may not fire if the underlying AudioContext is closed prematurely\n      source.onended = sourceEnded.eventListener;\n\n      source.connect(audioContext.destination);\n      source.start(0);\n\n      Promise.race([audioContextClosed.upcoming(), sourceEnded.upcoming()]).then(resolve);\n    } catch (err) {\n      reject(err);\n    } finally {\n      unsubscribe();\n    }\n  });\n}\n\nclass SpeechSynthesisUtterance extends EventTarget {\n  constructor(text) {\n    super();\n\n    this._lang = null;\n    this._pitch = 1;\n    this._rate = 1;\n    this._voice = null;\n    this._volume = 1;\n\n    this.text = text;\n\n    this.onboundary = null;\n    this.onend = null;\n    this.onerror = null;\n    this.onmark = null;\n    this.onpause = null;\n    this.onresume = null;\n    this.onstart = null;\n  }\n\n  get lang() {\n    return this._lang;\n  }\n\n  set lang(value) {\n    this._lang = value;\n  }\n\n  get pitch() {\n    return this._pitch;\n  }\n\n  set pitch(value) {\n    this._pitch = value;\n  }\n\n  get rate() {\n    return this._rate;\n  }\n\n  set rate(value) {\n    this._rate = value;\n  }\n\n  get voice() {\n    return this._voice;\n  }\n\n  set voice(value) {\n    this._voice = value;\n  }\n\n  get volume() {\n    return this._volume;\n  }\n\n  set volume(value) {\n    this._volume = value;\n  }\n\n  preload({\n    deploymentId,\n    fetchCredentials,\n    outputFormat\n  }) {\n    this.arrayBufferPromise = fetchSpeechData({\n      fetchCredentials,\n      deploymentId,\n      lang: this.lang || window.navigator.language,\n      outputFormat,\n      pitch: this.pitch,\n      rate: this.rate,\n      text: this.text,\n      voice: this.voice && this.voice.voiceURI,\n      volume: this.volume\n    });\n\n    // We need to call \"catch\" to make sure the Promise is running.\n    // We will ignore the reject result and handled in play() later.\n    this.arrayBufferPromise.catch();\n  }\n\n  async play(audioContext) {\n    try {\n      // We should emit \"start\" event even if preload() failed.\n      this.dispatchEvent(new SpeechSynthesisEvent('start'));\n\n      // HACK: iOS requires bufferSourceNode to be constructed before decoding data.\n      const source = audioContext.createBufferSource();\n      const audioBuffer = await asyncDecodeAudioData(audioContext, await this.arrayBufferPromise);\n\n      this._playingSource = source;\n\n      await playDecoded(audioContext, audioBuffer, source);\n\n      this._playingSource = null;\n      this.dispatchEvent(new SpeechSynthesisEvent('end'));\n    } catch (error) {\n      // \"message\" is not in spec but to provide a friendly message.\n      this.dispatchEvent(new ErrorEvent('error', { error: 'synthesis-failed', message: error.stack }));\n    }\n  }\n\n  stop() {\n    this._playingSource && this._playingSource.stop();\n  }\n}\n\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'boundary');\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'end');\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'error');\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'mark');\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'pause');\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'resume');\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'start');\n\nexport default SpeechSynthesisUtterance;\n"],"file":"SpeechSynthesisUtterance.js"}