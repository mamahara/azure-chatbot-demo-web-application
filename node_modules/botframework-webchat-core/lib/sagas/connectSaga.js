"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _callee;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _effects = require("redux-saga/effects");

var _botframeworkDirectlinejs = require("botframework-directlinejs");

var _jsonwebtoken = require("jsonwebtoken");

var _connect = require("../actions/connect");

var _createPromiseQueue = _interopRequireDefault(require("../createPromiseQueue"));

var _forkPut = _interopRequireDefault(require("./effects/forkPut"));

var _uniqueID = _interopRequireDefault(require("../utils/uniqueID"));

var _updateConnectionStatus = _interopRequireWildcard(require("../actions/updateConnectionStatus"));

var _disconnect = require("../actions/disconnect");

var _reconnect = require("../actions/reconnect");

var _marked = /*#__PURE__*/_regenerator["default"].mark(observeAndPutConnectionStatusUpdate),
    _marked2 = /*#__PURE__*/_regenerator["default"].mark(connectSaga),
    _marked3 = /*#__PURE__*/_regenerator["default"].mark(reconnectSaga),
    _marked4 = /*#__PURE__*/_regenerator["default"].mark(runAsyncEffect),
    _marked5 = /*#__PURE__*/_regenerator["default"].mark(takeDisconnectAsError),
    _marked6 = /*#__PURE__*/_regenerator["default"].mark(_callee);

var CONNECTING = _botframeworkDirectlinejs.ConnectionStatus.Connecting,
    ONLINE = _botframeworkDirectlinejs.ConnectionStatus.Online,
    UNINITIALIZED = _botframeworkDirectlinejs.ConnectionStatus.Uninitialized;

function randomUserID() {
  return "r_".concat((0, _uniqueID["default"])().substr(0, 10));
}

function observeAndPutConnectionStatusUpdate(directLine) {
  var connectionStatusQueue, connectionStatusSubscription, connectionStatus;
  return _regenerator["default"].wrap(function observeAndPutConnectionStatusUpdate$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          connectionStatusQueue = (0, _createPromiseQueue["default"])();
          connectionStatusSubscription = directLine.connectionStatus$.subscribe({
            next: connectionStatusQueue.push
          });
          _context.prev = 2;

        case 3:
          _context.next = 5;
          return (0, _effects.call)(connectionStatusQueue.shift);

        case 5:
          connectionStatus = _context.sent;
          _context.next = 8;
          return (0, _effects.put)((0, _updateConnectionStatus["default"])(connectionStatus));

        case 8:
          _context.next = 3;
          break;

        case 10:
          _context.prev = 10;
          connectionStatusSubscription.unsubscribe();
          return _context.finish(10);

        case 13:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[2,, 10, 13]]);
} // TODO: [P2] We should move this check and rectification to DirectLineJS.


function rectifyUserID(directLine, userIDFromAction) {
  var token = directLine.token;

  var _ref = (0, _jsonwebtoken.decode)(token) || {},
      userIDFromToken = _ref.user;

  if (userIDFromToken) {
    if (userIDFromAction && userIDFromAction !== userIDFromToken) {
      console.warn('Web Chat: user ID is both specified in the Direct Line token and passed in, will use the user ID from the token.');
    }

    return userIDFromToken;
  } else if (userIDFromAction) {
    if (typeof userIDFromAction !== 'string') {
      console.warn('Web Chat: user ID must be a string.');
      return randomUserID();
    } else if (/^dl_/.test(userIDFromAction)) {
      console.warn('Web Chat: user ID prefixed with "dl_" is reserved and must be embedded into the Direct Line token to prevent forgery.');
      return randomUserID();
    }
  } else {
    return randomUserID();
  }

  return userIDFromAction;
} // We could make this a Promise instead of saga (function generator) to make the code cleaner, if:
// 1. We found a way to cancel Promise
// 2. subscribe() are shared amongst all subscriptions, e.g. turn Observable into events


function connectSaga(directLine) {
  var activitySubscription, unsubscribeActivity, _yield$take, connectionStatus;

  return _regenerator["default"].wrap(function connectSaga$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          // DirectLineJS starts the connection only after the first subscriber for activity$, not connectionStatus$
          activitySubscription = directLine.activity$.subscribe({
            next: function next() {
              return 0;
            }
          });
          unsubscribeActivity = activitySubscription.unsubscribe.bind(activitySubscription);
          _context2.prev = 2;

        case 3:
          _context2.next = 5;
          return (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS);

        case 5:
          _yield$take = _context2.sent;
          connectionStatus = _yield$take.payload.connectionStatus;

          if (!(connectionStatus === ONLINE)) {
            _context2.next = 11;
            break;
          }

          return _context2.abrupt("return", function () {
            unsubscribeActivity();
            directLine.end();
          });

        case 11:
          if (!(connectionStatus !== UNINITIALIZED && connectionStatus !== CONNECTING)) {
            _context2.next = 13;
            break;
          }

          throw new Error("Failed to connect, DirectLineJS returned ".concat(connectionStatus, "."));

        case 13:
          _context2.next = 3;
          break;

        case 15:
          _context2.next = 21;
          break;

        case 17:
          _context2.prev = 17;
          _context2.t0 = _context2["catch"](2);
          // We will unsubscribe if we failed to connect or got cancelled only.
          // We should not unsubscribe in happy case, because DirectLineJS should relying on the subscription to connect/disconnect.
          unsubscribeActivity();
          throw _context2.t0;

        case 21:
          _context2.prev = 21;
          _context2.next = 24;
          return (0, _effects.cancelled)();

        case 24:
          if (!_context2.sent) {
            _context2.next = 26;
            break;
          }

          unsubscribeActivity();

        case 26:
          return _context2.finish(21);

        case 27:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, null, [[2, 17, 21, 27]]);
}

function reconnectSaga() {
  var _yield$take2, connectionStatus;

  return _regenerator["default"].wrap(function reconnectSaga$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS);

        case 2:
          _yield$take2 = _context3.sent;
          connectionStatus = _yield$take2.payload.connectionStatus;

          if (!(connectionStatus === ONLINE)) {
            _context3.next = 8;
            break;
          }

          return _context3.abrupt("break", 12);

        case 8:
          if (!(connectionStatus !== CONNECTING)) {
            _context3.next = 10;
            break;
          }

          throw new Error("Failed to reconnect. DirectLineJS returned ".concat(connectionStatus, "."));

        case 10:
          _context3.next = 0;
          break;

        case 12:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
} // This is similar to behavior of redux-promise-middleware, but using saga instead of Promise.
// We guarantee PENDING -> FULFILLING -> FULFILLED, or PENDING -> REJECTED. This will help us simplify logic in other part of code.
// Note that after the saga is cancelled, subsequent call to put() will be ignored silently.


function runAsyncEffect(_ref2, callEffectFactory) {
  var type, meta, payload, result;
  return _regenerator["default"].wrap(function runAsyncEffect$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          type = _ref2.type, meta = _ref2.meta, payload = _ref2.payload;
          _context4.prev = 1;
          _context4.next = 4;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_PENDING"),
            meta: meta,
            payload: payload
          });

        case 4:
          _context4.next = 6;
          return callEffectFactory();

        case 6:
          result = _context4.sent;
          _context4.next = 9;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_FULFILLING"),
            meta: meta,
            payload: payload
          }, {
            type: "".concat(type, "_FULFILLED"),
            meta: meta,
            payload: payload
          });

        case 9:
          return _context4.abrupt("return", result);

        case 12:
          _context4.prev = 12;
          _context4.t0 = _context4["catch"](1);
          _context4.next = 16;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_REJECTED"),
            error: true,
            meta: meta,
            payload: _context4.t0
          });

        case 16:
          throw _context4.t0;

        case 17:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, null, [[1, 12]]);
}

function takeDisconnectAsError() {
  return _regenerator["default"].wrap(function takeDisconnectAsError$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return (0, _effects.take)(_disconnect.DISCONNECT);

        case 2:
          throw new Error('disconnected');

        case 3:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5);
}

function runAsyncEffectUntilDisconnect(baseAction, callEffectFactory) {
  // We cannot use saga cancel() here, because cancelling saga will prohibit us from sending *_REJECTED.
  // Without REJECTED, it impacts our assumptions around PENDING/FULFILLED/REJECTED.
  return runAsyncEffect(baseAction, /*#__PURE__*/_regenerator["default"].mark(function runUntilDisconnect() {
    var _yield$race, result;

    return _regenerator["default"].wrap(function runUntilDisconnect$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return (0, _effects.race)({
              _: takeDisconnectAsError(),
              result: callEffectFactory()
            });

          case 2:
            _yield$race = _context6.sent;
            result = _yield$race.result;
            return _context6.abrupt("return", result);

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, runUntilDisconnect);
  }));
}

function _callee() {
  var _loop;

  return _regenerator["default"].wrap(function _callee$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _loop = /*#__PURE__*/_regenerator["default"].mark(function _loop() {
            var _yield$take3, _yield$take3$payload, directLine, userIDFromAction, username, updateConnectionStatusTask, disconnectMeta, meta, endDirectLine, _yield$race2, _yield$race2$updateCo, _yield$race2$updateCo2, connectionStatus;

            return _regenerator["default"].wrap(function _loop$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return (0, _effects.take)(_connect.CONNECT);

                  case 2:
                    _yield$take3 = _context7.sent;
                    _yield$take3$payload = _yield$take3.payload;
                    directLine = _yield$take3$payload.directLine;
                    userIDFromAction = _yield$take3$payload.userID;
                    username = _yield$take3$payload.username;
                    _context7.next = 9;
                    return (0, _effects.fork)(observeAndPutConnectionStatusUpdate, directLine);

                  case 9:
                    updateConnectionStatusTask = _context7.sent;
                    disconnectMeta = void 0; // TODO: [P2] Checks if this attached subtask will get killed if the parent task is complete (peacefully), errored out, or cancelled.

                    meta = {
                      userID: rectifyUserID(directLine, userIDFromAction),
                      username: username
                    }; // We will dispatch CONNECT_PENDING, wait for connect completed, errored, or cancelled (thru disconnect).
                    // Then dispatch CONNECT_FULFILLED/CONNECT_REJECTED as needed.

                    _context7.prev = 12;
                    _context7.next = 15;
                    return runAsyncEffectUntilDisconnect({
                      type: _connect.CONNECT,
                      meta: meta,
                      payload: {
                        directLine: directLine
                      }
                    }, function () {
                      return (0, _effects.call)(connectSaga, directLine);
                    });

                  case 15:
                    endDirectLine = _context7.sent;
                    _context7.prev = 16;

                  case 17:
                    _context7.next = 19;
                    return (0, _effects.race)({
                      _: (0, _effects.take)(_disconnect.DISCONNECT),
                      updateConnectionStatusAction: (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS)
                    });

                  case 19:
                    _yield$race2 = _context7.sent;
                    _yield$race2$updateCo = _yield$race2.updateConnectionStatusAction;
                    _yield$race2$updateCo = _yield$race2$updateCo === void 0 ? {} : _yield$race2$updateCo;
                    _yield$race2$updateCo2 = _yield$race2$updateCo.payload;
                    _yield$race2$updateCo2 = _yield$race2$updateCo2 === void 0 ? {} : _yield$race2$updateCo2;
                    connectionStatus = _yield$race2$updateCo2.connectionStatus; // If it is not disconnect action, connectionStatus will not be undefined.

                    if (!(connectionStatus === CONNECTING)) {
                      _context7.next = 30;
                      break;
                    }

                    _context7.next = 28;
                    return runAsyncEffectUntilDisconnect({
                      type: _reconnect.RECONNECT,
                      meta: meta,
                      payload: {
                        directLine: directLine
                      }
                    }, function () {
                      return (0, _effects.call)(reconnectSaga);
                    });

                  case 28:
                    _context7.next = 36;
                    break;

                  case 30:
                    if (!(connectionStatus !== ONLINE)) {
                      _context7.next = 36;
                      break;
                    }

                    if (!(typeof connectionStatus !== 'undefined')) {
                      _context7.next = 35;
                      break;
                    }

                    throw new Error("Connection status changed to ".concat(connectionStatus));

                  case 35:
                    return _context7.abrupt("break", 38);

                  case 36:
                    _context7.next = 17;
                    break;

                  case 38:
                    _context7.prev = 38;
                    endDirectLine();
                    return _context7.finish(38);

                  case 41:
                    _context7.next = 46;
                    break;

                  case 43:
                    _context7.prev = 43;
                    _context7.t0 = _context7["catch"](12);
                    disconnectMeta = {
                      error: _context7.t0
                    };

                  case 46:
                    _context7.prev = 46;
                    _context7.next = 49;
                    return (0, _effects.cancel)(updateConnectionStatusTask);

                  case 49:
                    _context7.next = 51;
                    return (0, _forkPut["default"])({
                      type: _disconnect.DISCONNECT_PENDING,
                      meta: disconnectMeta,
                      payload: {
                        directLine: directLine
                      }
                    }, {
                      type: _disconnect.DISCONNECT_FULFILLED,
                      meta: disconnectMeta,
                      payload: {
                        directLine: directLine
                      }
                    });

                  case 51:
                    return _context7.finish(46);

                  case 52:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _loop, null, [[12, 43, 46, 52], [16,, 38, 41]]);
          });

        case 1:
          return _context8.delegateYield(_loop(), "t0", 2);

        case 2:
          _context8.next = 1;
          break;

        case 4:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked6);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zYWdhcy9jb25uZWN0U2FnYS5qcyJdLCJuYW1lcyI6WyJvYnNlcnZlQW5kUHV0Q29ubmVjdGlvblN0YXR1c1VwZGF0ZSIsImNvbm5lY3RTYWdhIiwicmVjb25uZWN0U2FnYSIsInJ1bkFzeW5jRWZmZWN0IiwidGFrZURpc2Nvbm5lY3RBc0Vycm9yIiwiQ09OTkVDVElORyIsIkNvbm5lY3Rpb25TdGF0dXMiLCJDb25uZWN0aW5nIiwiT05MSU5FIiwiT25saW5lIiwiVU5JTklUSUFMSVpFRCIsIlVuaW5pdGlhbGl6ZWQiLCJyYW5kb21Vc2VySUQiLCJzdWJzdHIiLCJkaXJlY3RMaW5lIiwiY29ubmVjdGlvblN0YXR1c1F1ZXVlIiwiY29ubmVjdGlvblN0YXR1c1N1YnNjcmlwdGlvbiIsImNvbm5lY3Rpb25TdGF0dXMkIiwic3Vic2NyaWJlIiwibmV4dCIsInB1c2giLCJzaGlmdCIsImNvbm5lY3Rpb25TdGF0dXMiLCJ1bnN1YnNjcmliZSIsInJlY3RpZnlVc2VySUQiLCJ1c2VySURGcm9tQWN0aW9uIiwidG9rZW4iLCJ1c2VySURGcm9tVG9rZW4iLCJ1c2VyIiwiY29uc29sZSIsIndhcm4iLCJ0ZXN0IiwiYWN0aXZpdHlTdWJzY3JpcHRpb24iLCJhY3Rpdml0eSQiLCJ1bnN1YnNjcmliZUFjdGl2aXR5IiwiYmluZCIsIlVQREFURV9DT05ORUNUSU9OX1NUQVRVUyIsInBheWxvYWQiLCJlbmQiLCJFcnJvciIsImNhbGxFZmZlY3RGYWN0b3J5IiwidHlwZSIsIm1ldGEiLCJyZXN1bHQiLCJlcnJvciIsIkRJU0NPTk5FQ1QiLCJydW5Bc3luY0VmZmVjdFVudGlsRGlzY29ubmVjdCIsImJhc2VBY3Rpb24iLCJydW5VbnRpbERpc2Nvbm5lY3QiLCJfIiwiQ09OTkVDVCIsInVzZXJJRCIsInVzZXJuYW1lIiwidXBkYXRlQ29ubmVjdGlvblN0YXR1c1Rhc2siLCJkaXNjb25uZWN0TWV0YSIsImVuZERpcmVjdExpbmUiLCJ1cGRhdGVDb25uZWN0aW9uU3RhdHVzQWN0aW9uIiwiUkVDT05ORUNUIiwiRElTQ09OTkVDVF9QRU5ESU5HIiwiRElTQ09OTkVDVF9GVUxGSUxMRUQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFFQTs7d0RBUVVBLG1DO3lEQWtEQUMsVzt5REFxQ0FDLGE7eURBaUJBQyxjO3lEQWdCQUMscUI7OztJQTlIVUMsVSxHQUE2REMsMEMsQ0FBekVDLFU7SUFBZ0NDLE0sR0FBeUNGLDBDLENBQWpERyxNO0lBQStCQyxhLEdBQWtCSiwwQyxDQUFqQ0ssYTs7QUFFaEQsU0FBU0MsWUFBVCxHQUF3QjtBQUN0QixxQkFBWSw0QkFBV0MsTUFBWCxDQUFrQixDQUFsQixFQUFxQixFQUFyQixDQUFaO0FBQ0Q7O0FBRUQsU0FBVWIsbUNBQVYsQ0FBOENjLFVBQTlDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNRQyxVQUFBQSxxQkFEUixHQUNnQyxxQ0FEaEM7QUFFUUMsVUFBQUEsNEJBRlIsR0FFdUNGLFVBQVUsQ0FBQ0csaUJBQVgsQ0FBNkJDLFNBQTdCLENBQXVDO0FBQUVDLFlBQUFBLElBQUksRUFBRUoscUJBQXFCLENBQUNLO0FBQTlCLFdBQXZDLENBRnZDO0FBQUE7O0FBQUE7QUFBQTtBQU0rQixpQkFBTSxtQkFBS0wscUJBQXFCLENBQUNNLEtBQTNCLENBQU47O0FBTi9CO0FBTVlDLFVBQUFBLGdCQU5aO0FBQUE7QUFRTSxpQkFBTSxrQkFBSSx3Q0FBdUJBLGdCQUF2QixDQUFKLENBQU47O0FBUk47QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFXSU4sVUFBQUEsNEJBQTRCLENBQUNPLFdBQTdCO0FBWEo7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsQyxDQWVBOzs7QUFDQSxTQUFTQyxhQUFULENBQXVCVixVQUF2QixFQUFtQ1csZ0JBQW5DLEVBQXFEO0FBQUEsTUFDM0NDLEtBRDJDLEdBQ2pDWixVQURpQyxDQUMzQ1ksS0FEMkM7O0FBQUEsYUFFakIsMEJBQU9BLEtBQVAsS0FBaUIsRUFGQTtBQUFBLE1BRXJDQyxlQUZxQyxRQUUzQ0MsSUFGMkM7O0FBSW5ELE1BQUlELGVBQUosRUFBcUI7QUFDbkIsUUFBSUYsZ0JBQWdCLElBQUlBLGdCQUFnQixLQUFLRSxlQUE3QyxFQUE4RDtBQUM1REUsTUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQ0Usa0hBREY7QUFHRDs7QUFFRCxXQUFPSCxlQUFQO0FBQ0QsR0FSRCxNQVFPLElBQUlGLGdCQUFKLEVBQXNCO0FBQzNCLFFBQUksT0FBT0EsZ0JBQVAsS0FBNEIsUUFBaEMsRUFBMEM7QUFDeENJLE1BQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLHFDQUFiO0FBRUEsYUFBT2xCLFlBQVksRUFBbkI7QUFDRCxLQUpELE1BSU8sSUFBSSxPQUFRbUIsSUFBUixDQUFhTixnQkFBYixDQUFKLEVBQW9DO0FBQ3pDSSxNQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FDRSx1SEFERjtBQUlBLGFBQU9sQixZQUFZLEVBQW5CO0FBQ0Q7QUFDRixHQVpNLE1BWUE7QUFDTCxXQUFPQSxZQUFZLEVBQW5CO0FBQ0Q7O0FBRUQsU0FBT2EsZ0JBQVA7QUFDRCxDLENBRUQ7QUFDQTtBQUNBOzs7QUFDQSxTQUFVeEIsV0FBVixDQUFzQmEsVUFBdEI7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNFO0FBQ01rQixVQUFBQSxvQkFGUixHQUUrQmxCLFVBQVUsQ0FBQ21CLFNBQVgsQ0FBcUJmLFNBQXJCLENBQStCO0FBQUVDLFlBQUFBLElBQUksRUFBRTtBQUFBLHFCQUFNLENBQU47QUFBQTtBQUFSLFdBQS9CLENBRi9CO0FBR1FlLFVBQUFBLG1CQUhSLEdBRzhCRixvQkFBb0IsQ0FBQ1QsV0FBckIsQ0FBaUNZLElBQWpDLENBQXNDSCxvQkFBdEMsQ0FIOUI7QUFBQTs7QUFBQTtBQUFBO0FBU1UsaUJBQU0sbUJBQUtJLGdEQUFMLENBQU47O0FBVFY7QUFBQTtBQVFtQmQsVUFBQUEsZ0JBUm5CLGVBUVFlLE9BUlIsQ0FRbUJmLGdCQVJuQjs7QUFBQSxnQkFXVUEsZ0JBQWdCLEtBQUtkLE1BWC9CO0FBQUE7QUFBQTtBQUFBOztBQUFBLDRDQWdCZSxZQUFNO0FBQ1gwQixZQUFBQSxtQkFBbUI7QUFDbkJwQixZQUFBQSxVQUFVLENBQUN3QixHQUFYO0FBQ0QsV0FuQlQ7O0FBQUE7QUFBQSxnQkFvQmlCaEIsZ0JBQWdCLEtBQUtaLGFBQXJCLElBQXNDWSxnQkFBZ0IsS0FBS2pCLFVBcEI1RTtBQUFBO0FBQUE7QUFBQTs7QUFBQSxnQkFxQmMsSUFBSWtDLEtBQUosb0RBQXNEakIsZ0JBQXRELE9BckJkOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBeUJJO0FBQ0E7QUFDQVksVUFBQUEsbUJBQW1CO0FBM0J2Qjs7QUFBQTtBQUFBO0FBQUE7QUErQlEsaUJBQU0seUJBQU47O0FBL0JSO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBZ0NNQSxVQUFBQSxtQkFBbUI7O0FBaEN6QjtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQXFDQSxTQUFVaEMsYUFBVjtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJUSxpQkFBTSxtQkFBS2tDLGdEQUFMLENBQU47O0FBSlI7QUFBQTtBQUdpQmQsVUFBQUEsZ0JBSGpCLGdCQUdNZSxPQUhOLENBR2lCZixnQkFIakI7O0FBQUEsZ0JBTVFBLGdCQUFnQixLQUFLZCxNQU43QjtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBLGdCQVFlYyxnQkFBZ0IsS0FBS2pCLFVBUnBDO0FBQUE7QUFBQTtBQUFBOztBQUFBLGdCQVNZLElBQUlrQyxLQUFKLHNEQUF3RGpCLGdCQUF4RCxPQVRaOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxDLENBY0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFVbkIsY0FBVixRQUFrRHFDLGlCQUFsRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMkJDLFVBQUFBLElBQTNCLFNBQTJCQSxJQUEzQixFQUFpQ0MsSUFBakMsU0FBaUNBLElBQWpDLEVBQXVDTCxPQUF2QyxTQUF1Q0EsT0FBdkM7QUFBQTtBQUFBO0FBRUksaUJBQU0seUJBQVE7QUFBRUksWUFBQUEsSUFBSSxZQUFLQSxJQUFMLGFBQU47QUFBMkJDLFlBQUFBLElBQUksRUFBSkEsSUFBM0I7QUFBaUNMLFlBQUFBLE9BQU8sRUFBUEE7QUFBakMsV0FBUixDQUFOOztBQUZKO0FBQUE7QUFJbUIsaUJBQU1HLGlCQUFpQixFQUF2Qjs7QUFKbkI7QUFJVUcsVUFBQUEsTUFKVjtBQUFBO0FBTUksaUJBQU0seUJBQVE7QUFBRUYsWUFBQUEsSUFBSSxZQUFLQSxJQUFMLGdCQUFOO0FBQThCQyxZQUFBQSxJQUFJLEVBQUpBLElBQTlCO0FBQW9DTCxZQUFBQSxPQUFPLEVBQVBBO0FBQXBDLFdBQVIsRUFBdUQ7QUFBRUksWUFBQUEsSUFBSSxZQUFLQSxJQUFMLGVBQU47QUFBNkJDLFlBQUFBLElBQUksRUFBSkEsSUFBN0I7QUFBbUNMLFlBQUFBLE9BQU8sRUFBUEE7QUFBbkMsV0FBdkQsQ0FBTjs7QUFOSjtBQUFBLDRDQVFXTSxNQVJYOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVUksaUJBQU0seUJBQVE7QUFBRUYsWUFBQUEsSUFBSSxZQUFLQSxJQUFMLGNBQU47QUFBNEJHLFlBQUFBLEtBQUssRUFBRSxJQUFuQztBQUF5Q0YsWUFBQUEsSUFBSSxFQUFKQSxJQUF6QztBQUErQ0wsWUFBQUEsT0FBTztBQUF0RCxXQUFSLENBQU47O0FBVko7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFnQkEsU0FBVWpDLHFCQUFWO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNFLGlCQUFNLG1CQUFLeUMsc0JBQUwsQ0FBTjs7QUFERjtBQUFBLGdCQUdRLElBQUlOLEtBQUosQ0FBVSxjQUFWLENBSFI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTUEsU0FBU08sNkJBQVQsQ0FBdUNDLFVBQXZDLEVBQW1EUCxpQkFBbkQsRUFBc0U7QUFDcEU7QUFDQTtBQUNBLFNBQU9yQyxjQUFjLENBQUM0QyxVQUFELDRDQUFhLFNBQVVDLGtCQUFWO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNiLG1CQUFNLG1CQUFLO0FBQzVCQyxjQUFBQSxDQUFDLEVBQUU3QyxxQkFBcUIsRUFESTtBQUU1QnVDLGNBQUFBLE1BQU0sRUFBRUgsaUJBQWlCO0FBRkcsYUFBTCxDQUFOOztBQURhO0FBQUE7QUFDeEJHLFlBQUFBLE1BRHdCLGVBQ3hCQSxNQUR3QjtBQUFBLDhDQU16QkEsTUFOeUI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BQVVLLGtCQUFWO0FBQUEsR0FBYixFQUFyQjtBQVFEOztBQUVjO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJUCwyQkFBTSxtQkFBS0UsZ0JBQUwsQ0FBTjs7QUFKTztBQUFBO0FBQUEsd0RBR1RiLE9BSFM7QUFHRXZCLG9CQUFBQSxVQUhGLHdCQUdFQSxVQUhGO0FBR3NCVyxvQkFBQUEsZ0JBSHRCLHdCQUdjMEIsTUFIZDtBQUd3Q0Msb0JBQUFBLFFBSHhDLHdCQUd3Q0EsUUFIeEM7QUFBQTtBQU13QiwyQkFBTSxtQkFBS3BELG1DQUFMLEVBQTBDYyxVQUExQyxDQUFOOztBQU54QjtBQU1MdUMsb0JBQUFBLDBCQU5LO0FBT1BDLG9CQUFBQSxjQVBPLFdBU1g7O0FBQ01aLG9CQUFBQSxJQVZLLEdBVUU7QUFDWFMsc0JBQUFBLE1BQU0sRUFBRTNCLGFBQWEsQ0FBQ1YsVUFBRCxFQUFhVyxnQkFBYixDQURWO0FBRVgyQixzQkFBQUEsUUFBUSxFQUFSQTtBQUZXLHFCQVZGLEVBZVg7QUFDQTs7QUFoQlc7QUFBQTtBQWtCYSwyQkFBTU4sNkJBQTZCLENBQ3ZEO0FBQ0VMLHNCQUFBQSxJQUFJLEVBQUVTLGdCQURSO0FBRUVSLHNCQUFBQSxJQUFJLEVBQUpBLElBRkY7QUFHRUwsc0JBQUFBLE9BQU8sRUFBRTtBQUFFdkIsd0JBQUFBLFVBQVUsRUFBVkE7QUFBRjtBQUhYLHFCQUR1RCxFQU12RDtBQUFBLDZCQUFNLG1CQUFLYixXQUFMLEVBQWtCYSxVQUFsQixDQUFOO0FBQUEscUJBTnVELENBQW5DOztBQWxCYjtBQWtCSHlDLG9CQUFBQSxhQWxCRztBQUFBOztBQUFBO0FBQUE7QUE4QmlGLDJCQUFNLG1CQUFLO0FBQy9GTixzQkFBQUEsQ0FBQyxFQUFFLG1CQUFLSixzQkFBTCxDQUQ0RjtBQUUvRlcsc0JBQUFBLDRCQUE0QixFQUFFLG1CQUFLcEIsZ0RBQUw7QUFGaUUscUJBQUwsQ0FBTjs7QUE5QmpGO0FBQUE7QUFBQSx5REE4QkdvQiw0QkE5Qkg7QUFBQSwrRUE4QjBFLEVBOUIxRTtBQUFBLG1FQThCbUNuQixPQTlCbkM7QUFBQSxpRkE4Qm1FLEVBOUJuRTtBQThCOENmLG9CQUFBQSxnQkE5QjlDLDBCQThCOENBLGdCQTlCOUMsRUFtQ0w7O0FBbkNLLDBCQW9DREEsZ0JBQWdCLEtBQUtqQixVQXBDcEI7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFzQ0gsMkJBQU15Qyw2QkFBNkIsQ0FDakM7QUFDRUwsc0JBQUFBLElBQUksRUFBRWdCLG9CQURSO0FBRUVmLHNCQUFBQSxJQUFJLEVBQUpBLElBRkY7QUFHRUwsc0JBQUFBLE9BQU8sRUFBRTtBQUFFdkIsd0JBQUFBLFVBQVUsRUFBVkE7QUFBRjtBQUhYLHFCQURpQyxFQU1qQztBQUFBLDZCQUFNLG1CQUFLWixhQUFMLENBQU47QUFBQSxxQkFOaUMsQ0FBbkM7O0FBdENHO0FBQUE7QUFBQTs7QUFBQTtBQUFBLDBCQThDTW9CLGdCQUFnQixLQUFLZCxNQTlDM0I7QUFBQTtBQUFBO0FBQUE7O0FBQUEsMEJBK0NDLE9BQU9jLGdCQUFQLEtBQTRCLFdBL0M3QjtBQUFBO0FBQUE7QUFBQTs7QUFBQSwwQkFpREssSUFBSWlCLEtBQUosd0NBQTBDakIsZ0JBQTFDLEVBakRMOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUF5RFBpQyxvQkFBQUEsYUFBYTtBQXpETjs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBNERURCxvQkFBQUEsY0FBYyxHQUFHO0FBQUVWLHNCQUFBQSxLQUFLO0FBQVAscUJBQWpCOztBQTVEUztBQUFBO0FBQUE7QUE4RFQsMkJBQU0scUJBQU9TLDBCQUFQLENBQU47O0FBOURTO0FBQUE7QUFrRVQsMkJBQU0seUJBQ0o7QUFBRVosc0JBQUFBLElBQUksRUFBRWlCLDhCQUFSO0FBQTRCaEIsc0JBQUFBLElBQUksRUFBRVksY0FBbEM7QUFBa0RqQixzQkFBQUEsT0FBTyxFQUFFO0FBQUV2Qix3QkFBQUEsVUFBVSxFQUFWQTtBQUFGO0FBQTNELHFCQURJLEVBRUo7QUFBRTJCLHNCQUFBQSxJQUFJLEVBQUVrQixnQ0FBUjtBQUE4QmpCLHNCQUFBQSxJQUFJLEVBQUVZLGNBQXBDO0FBQW9EakIsc0JBQUFBLE9BQU8sRUFBRTtBQUFFdkIsd0JBQUFBLFVBQVUsRUFBVkE7QUFBRjtBQUE3RCxxQkFGSSxDQUFOOztBQWxFUztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6ImNvcmU6Ly8vIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLW1hZ2ljLW51bWJlcnM6IFtcImVycm9yXCIsIHsgXCJpZ25vcmVcIjogWzAsIDEwXSB9XSAqL1xuXG5pbXBvcnQgeyBjYWxsLCBjYW5jZWwsIGNhbmNlbGxlZCwgZm9yaywgcHV0LCByYWNlLCB0YWtlIH0gZnJvbSAncmVkdXgtc2FnYS9lZmZlY3RzJztcblxuaW1wb3J0IHsgQ29ubmVjdGlvblN0YXR1cyB9IGZyb20gJ2JvdGZyYW1ld29yay1kaXJlY3RsaW5lanMnO1xuaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSAnanNvbndlYnRva2VuJztcblxuaW1wb3J0IHsgQ09OTkVDVCB9IGZyb20gJy4uL2FjdGlvbnMvY29ubmVjdCc7XG5pbXBvcnQgY3JlYXRlUHJvbWlzZVF1ZXVlIGZyb20gJy4uL2NyZWF0ZVByb21pc2VRdWV1ZSc7XG5pbXBvcnQgZm9ya1B1dCBmcm9tICcuL2VmZmVjdHMvZm9ya1B1dCc7XG5pbXBvcnQgdW5pcXVlSUQgZnJvbSAnLi4vdXRpbHMvdW5pcXVlSUQnO1xuaW1wb3J0IHVwZGF0ZUNvbm5lY3Rpb25TdGF0dXMsIHsgVVBEQVRFX0NPTk5FQ1RJT05fU1RBVFVTIH0gZnJvbSAnLi4vYWN0aW9ucy91cGRhdGVDb25uZWN0aW9uU3RhdHVzJztcblxuaW1wb3J0IHsgRElTQ09OTkVDVCwgRElTQ09OTkVDVF9QRU5ESU5HLCBESVNDT05ORUNUX0ZVTEZJTExFRCB9IGZyb20gJy4uL2FjdGlvbnMvZGlzY29ubmVjdCc7XG5cbmltcG9ydCB7IFJFQ09OTkVDVCB9IGZyb20gJy4uL2FjdGlvbnMvcmVjb25uZWN0JztcblxuY29uc3QgeyBDb25uZWN0aW5nOiBDT05ORUNUSU5HLCBPbmxpbmU6IE9OTElORSwgVW5pbml0aWFsaXplZDogVU5JTklUSUFMSVpFRCB9ID0gQ29ubmVjdGlvblN0YXR1cztcblxuZnVuY3Rpb24gcmFuZG9tVXNlcklEKCkge1xuICByZXR1cm4gYHJfJHt1bmlxdWVJRCgpLnN1YnN0cigwLCAxMCl9YDtcbn1cblxuZnVuY3Rpb24qIG9ic2VydmVBbmRQdXRDb25uZWN0aW9uU3RhdHVzVXBkYXRlKGRpcmVjdExpbmUpIHtcbiAgY29uc3QgY29ubmVjdGlvblN0YXR1c1F1ZXVlID0gY3JlYXRlUHJvbWlzZVF1ZXVlKCk7XG4gIGNvbnN0IGNvbm5lY3Rpb25TdGF0dXNTdWJzY3JpcHRpb24gPSBkaXJlY3RMaW5lLmNvbm5lY3Rpb25TdGF0dXMkLnN1YnNjcmliZSh7IG5leHQ6IGNvbm5lY3Rpb25TdGF0dXNRdWV1ZS5wdXNoIH0pO1xuXG4gIHRyeSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3QgY29ubmVjdGlvblN0YXR1cyA9IHlpZWxkIGNhbGwoY29ubmVjdGlvblN0YXR1c1F1ZXVlLnNoaWZ0KTtcblxuICAgICAgeWllbGQgcHV0KHVwZGF0ZUNvbm5lY3Rpb25TdGF0dXMoY29ubmVjdGlvblN0YXR1cykpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBjb25uZWN0aW9uU3RhdHVzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cblxuLy8gVE9ETzogW1AyXSBXZSBzaG91bGQgbW92ZSB0aGlzIGNoZWNrIGFuZCByZWN0aWZpY2F0aW9uIHRvIERpcmVjdExpbmVKUy5cbmZ1bmN0aW9uIHJlY3RpZnlVc2VySUQoZGlyZWN0TGluZSwgdXNlcklERnJvbUFjdGlvbikge1xuICBjb25zdCB7IHRva2VuIH0gPSBkaXJlY3RMaW5lO1xuICBjb25zdCB7IHVzZXI6IHVzZXJJREZyb21Ub2tlbiB9ID0gZGVjb2RlKHRva2VuKSB8fCB7fTtcblxuICBpZiAodXNlcklERnJvbVRva2VuKSB7XG4gICAgaWYgKHVzZXJJREZyb21BY3Rpb24gJiYgdXNlcklERnJvbUFjdGlvbiAhPT0gdXNlcklERnJvbVRva2VuKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdXZWIgQ2hhdDogdXNlciBJRCBpcyBib3RoIHNwZWNpZmllZCBpbiB0aGUgRGlyZWN0IExpbmUgdG9rZW4gYW5kIHBhc3NlZCBpbiwgd2lsbCB1c2UgdGhlIHVzZXIgSUQgZnJvbSB0aGUgdG9rZW4uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXNlcklERnJvbVRva2VuO1xuICB9IGVsc2UgaWYgKHVzZXJJREZyb21BY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIHVzZXJJREZyb21BY3Rpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dlYiBDaGF0OiB1c2VyIElEIG11c3QgYmUgYSBzdHJpbmcuJyk7XG5cbiAgICAgIHJldHVybiByYW5kb21Vc2VySUQoKTtcbiAgICB9IGVsc2UgaWYgKC9eZGxfL3UudGVzdCh1c2VySURGcm9tQWN0aW9uKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnV2ViIENoYXQ6IHVzZXIgSUQgcHJlZml4ZWQgd2l0aCBcImRsX1wiIGlzIHJlc2VydmVkIGFuZCBtdXN0IGJlIGVtYmVkZGVkIGludG8gdGhlIERpcmVjdCBMaW5lIHRva2VuIHRvIHByZXZlbnQgZm9yZ2VyeS4nXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcmFuZG9tVXNlcklEKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByYW5kb21Vc2VySUQoKTtcbiAgfVxuXG4gIHJldHVybiB1c2VySURGcm9tQWN0aW9uO1xufVxuXG4vLyBXZSBjb3VsZCBtYWtlIHRoaXMgYSBQcm9taXNlIGluc3RlYWQgb2Ygc2FnYSAoZnVuY3Rpb24gZ2VuZXJhdG9yKSB0byBtYWtlIHRoZSBjb2RlIGNsZWFuZXIsIGlmOlxuLy8gMS4gV2UgZm91bmQgYSB3YXkgdG8gY2FuY2VsIFByb21pc2Vcbi8vIDIuIHN1YnNjcmliZSgpIGFyZSBzaGFyZWQgYW1vbmdzdCBhbGwgc3Vic2NyaXB0aW9ucywgZS5nLiB0dXJuIE9ic2VydmFibGUgaW50byBldmVudHNcbmZ1bmN0aW9uKiBjb25uZWN0U2FnYShkaXJlY3RMaW5lKSB7XG4gIC8vIERpcmVjdExpbmVKUyBzdGFydHMgdGhlIGNvbm5lY3Rpb24gb25seSBhZnRlciB0aGUgZmlyc3Qgc3Vic2NyaWJlciBmb3IgYWN0aXZpdHkkLCBub3QgY29ubmVjdGlvblN0YXR1cyRcbiAgY29uc3QgYWN0aXZpdHlTdWJzY3JpcHRpb24gPSBkaXJlY3RMaW5lLmFjdGl2aXR5JC5zdWJzY3JpYmUoeyBuZXh0OiAoKSA9PiAwIH0pO1xuICBjb25zdCB1bnN1YnNjcmliZUFjdGl2aXR5ID0gYWN0aXZpdHlTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUuYmluZChhY3Rpdml0eVN1YnNjcmlwdGlvbik7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBheWxvYWQ6IHsgY29ubmVjdGlvblN0YXR1cyB9XG4gICAgICB9ID0geWllbGQgdGFrZShVUERBVEVfQ09OTkVDVElPTl9TVEFUVVMpO1xuXG4gICAgICBpZiAoY29ubmVjdGlvblN0YXR1cyA9PT0gT05MSU5FKSB7XG4gICAgICAgIC8vIFRPRE86IFtQMl0gRGlyZWN0TGluZUpTIHNob3VsZCBraWxsIHRoZSBjb25uZWN0aW9uIHdoZW4gd2UgdW5zdWJzY3JpYmVcbiAgICAgICAgLy8gICAgICAgQnV0IGN1cnJlbnRseSBpbiB2MywgRGlyZWN0TGluZUpTIGRvZXMgbm90IGhhdmUgdGhpcyBmdW5jdGlvbmFsaXR5XG4gICAgICAgIC8vICAgICAgIFRodXMsIHdlIG5lZWQgdG8gY2FsbCBcImVuZCgpXCIgZXhwbGljaXRseVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVBY3Rpdml0eSgpO1xuICAgICAgICAgIGRpcmVjdExpbmUuZW5kKCk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0dXMgIT09IFVOSU5JVElBTElaRUQgJiYgY29ubmVjdGlvblN0YXR1cyAhPT0gQ09OTkVDVElORykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjb25uZWN0LCBEaXJlY3RMaW5lSlMgcmV0dXJuZWQgJHtjb25uZWN0aW9uU3RhdHVzfS5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFdlIHdpbGwgdW5zdWJzY3JpYmUgaWYgd2UgZmFpbGVkIHRvIGNvbm5lY3Qgb3IgZ290IGNhbmNlbGxlZCBvbmx5LlxuICAgIC8vIFdlIHNob3VsZCBub3QgdW5zdWJzY3JpYmUgaW4gaGFwcHkgY2FzZSwgYmVjYXVzZSBEaXJlY3RMaW5lSlMgc2hvdWxkIHJlbHlpbmcgb24gdGhlIHN1YnNjcmlwdGlvbiB0byBjb25uZWN0L2Rpc2Nvbm5lY3QuXG4gICAgdW5zdWJzY3JpYmVBY3Rpdml0eSgpO1xuXG4gICAgdGhyb3cgZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIGlmICh5aWVsZCBjYW5jZWxsZWQoKSkge1xuICAgICAgdW5zdWJzY3JpYmVBY3Rpdml0eSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiogcmVjb25uZWN0U2FnYSgpIHtcbiAgZm9yICg7Oykge1xuICAgIGNvbnN0IHtcbiAgICAgIHBheWxvYWQ6IHsgY29ubmVjdGlvblN0YXR1cyB9XG4gICAgfSA9IHlpZWxkIHRha2UoVVBEQVRFX0NPTk5FQ1RJT05fU1RBVFVTKTtcblxuICAgIGlmIChjb25uZWN0aW9uU3RhdHVzID09PSBPTkxJTkUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXR1cyAhPT0gQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVjb25uZWN0LiBEaXJlY3RMaW5lSlMgcmV0dXJuZWQgJHtjb25uZWN0aW9uU3RhdHVzfS5gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBpcyBzaW1pbGFyIHRvIGJlaGF2aW9yIG9mIHJlZHV4LXByb21pc2UtbWlkZGxld2FyZSwgYnV0IHVzaW5nIHNhZ2EgaW5zdGVhZCBvZiBQcm9taXNlLlxuLy8gV2UgZ3VhcmFudGVlIFBFTkRJTkcgLT4gRlVMRklMTElORyAtPiBGVUxGSUxMRUQsIG9yIFBFTkRJTkcgLT4gUkVKRUNURUQuIFRoaXMgd2lsbCBoZWxwIHVzIHNpbXBsaWZ5IGxvZ2ljIGluIG90aGVyIHBhcnQgb2YgY29kZS5cbi8vIE5vdGUgdGhhdCBhZnRlciB0aGUgc2FnYSBpcyBjYW5jZWxsZWQsIHN1YnNlcXVlbnQgY2FsbCB0byBwdXQoKSB3aWxsIGJlIGlnbm9yZWQgc2lsZW50bHkuXG5mdW5jdGlvbiogcnVuQXN5bmNFZmZlY3QoeyB0eXBlLCBtZXRhLCBwYXlsb2FkIH0sIGNhbGxFZmZlY3RGYWN0b3J5KSB7XG4gIHRyeSB7XG4gICAgeWllbGQgZm9ya1B1dCh7IHR5cGU6IGAke3R5cGV9X1BFTkRJTkdgLCBtZXRhLCBwYXlsb2FkIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0geWllbGQgY2FsbEVmZmVjdEZhY3RvcnkoKTtcblxuICAgIHlpZWxkIGZvcmtQdXQoeyB0eXBlOiBgJHt0eXBlfV9GVUxGSUxMSU5HYCwgbWV0YSwgcGF5bG9hZCB9LCB7IHR5cGU6IGAke3R5cGV9X0ZVTEZJTExFRGAsIG1ldGEsIHBheWxvYWQgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChwYXlsb2FkKSB7XG4gICAgeWllbGQgZm9ya1B1dCh7IHR5cGU6IGAke3R5cGV9X1JFSkVDVEVEYCwgZXJyb3I6IHRydWUsIG1ldGEsIHBheWxvYWQgfSk7XG5cbiAgICB0aHJvdyBwYXlsb2FkO1xuICB9XG59XG5cbmZ1bmN0aW9uKiB0YWtlRGlzY29ubmVjdEFzRXJyb3IoKSB7XG4gIHlpZWxkIHRha2UoRElTQ09OTkVDVCk7XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdkaXNjb25uZWN0ZWQnKTtcbn1cblxuZnVuY3Rpb24gcnVuQXN5bmNFZmZlY3RVbnRpbERpc2Nvbm5lY3QoYmFzZUFjdGlvbiwgY2FsbEVmZmVjdEZhY3RvcnkpIHtcbiAgLy8gV2UgY2Fubm90IHVzZSBzYWdhIGNhbmNlbCgpIGhlcmUsIGJlY2F1c2UgY2FuY2VsbGluZyBzYWdhIHdpbGwgcHJvaGliaXQgdXMgZnJvbSBzZW5kaW5nICpfUkVKRUNURUQuXG4gIC8vIFdpdGhvdXQgUkVKRUNURUQsIGl0IGltcGFjdHMgb3VyIGFzc3VtcHRpb25zIGFyb3VuZCBQRU5ESU5HL0ZVTEZJTExFRC9SRUpFQ1RFRC5cbiAgcmV0dXJuIHJ1bkFzeW5jRWZmZWN0KGJhc2VBY3Rpb24sIGZ1bmN0aW9uKiBydW5VbnRpbERpc2Nvbm5lY3QoKSB7XG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHlpZWxkIHJhY2Uoe1xuICAgICAgXzogdGFrZURpc2Nvbm5lY3RBc0Vycm9yKCksXG4gICAgICByZXN1bHQ6IGNhbGxFZmZlY3RGYWN0b3J5KClcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiooKSB7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXlsb2FkOiB7IGRpcmVjdExpbmUsIHVzZXJJRDogdXNlcklERnJvbUFjdGlvbiwgdXNlcm5hbWUgfVxuICAgIH0gPSB5aWVsZCB0YWtlKENPTk5FQ1QpO1xuXG4gICAgY29uc3QgdXBkYXRlQ29ubmVjdGlvblN0YXR1c1Rhc2sgPSB5aWVsZCBmb3JrKG9ic2VydmVBbmRQdXRDb25uZWN0aW9uU3RhdHVzVXBkYXRlLCBkaXJlY3RMaW5lKTtcbiAgICBsZXQgZGlzY29ubmVjdE1ldGE7XG5cbiAgICAvLyBUT0RPOiBbUDJdIENoZWNrcyBpZiB0aGlzIGF0dGFjaGVkIHN1YnRhc2sgd2lsbCBnZXQga2lsbGVkIGlmIHRoZSBwYXJlbnQgdGFzayBpcyBjb21wbGV0ZSAocGVhY2VmdWxseSksIGVycm9yZWQgb3V0LCBvciBjYW5jZWxsZWQuXG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgIHVzZXJJRDogcmVjdGlmeVVzZXJJRChkaXJlY3RMaW5lLCB1c2VySURGcm9tQWN0aW9uKSxcbiAgICAgIHVzZXJuYW1lXG4gICAgfTtcblxuICAgIC8vIFdlIHdpbGwgZGlzcGF0Y2ggQ09OTkVDVF9QRU5ESU5HLCB3YWl0IGZvciBjb25uZWN0IGNvbXBsZXRlZCwgZXJyb3JlZCwgb3IgY2FuY2VsbGVkICh0aHJ1IGRpc2Nvbm5lY3QpLlxuICAgIC8vIFRoZW4gZGlzcGF0Y2ggQ09OTkVDVF9GVUxGSUxMRUQvQ09OTkVDVF9SRUpFQ1RFRCBhcyBuZWVkZWQuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVuZERpcmVjdExpbmUgPSB5aWVsZCBydW5Bc3luY0VmZmVjdFVudGlsRGlzY29ubmVjdChcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IENPTk5FQ1QsXG4gICAgICAgICAgbWV0YSxcbiAgICAgICAgICBwYXlsb2FkOiB7IGRpcmVjdExpbmUgfVxuICAgICAgICB9LFxuICAgICAgICAoKSA9PiBjYWxsKGNvbm5lY3RTYWdhLCBkaXJlY3RMaW5lKVxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIC8vIFdlIGFyZSB3YWl0aW5nIGZvciBjb25uZWN0aW9uIHN0YXR1cyBjaGFuZ2Ugb3IgZGlzY29ubmVjdCBhY3Rpb24uXG4gICAgICAgICAgY29uc3QgeyB1cGRhdGVDb25uZWN0aW9uU3RhdHVzQWN0aW9uOiB7IHBheWxvYWQ6IHsgY29ubmVjdGlvblN0YXR1cyB9ID0ge30gfSA9IHt9IH0gPSB5aWVsZCByYWNlKHtcbiAgICAgICAgICAgIF86IHRha2UoRElTQ09OTkVDVCksXG4gICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uU3RhdHVzQWN0aW9uOiB0YWtlKFVQREFURV9DT05ORUNUSU9OX1NUQVRVUylcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIElmIGl0IGlzIG5vdCBkaXNjb25uZWN0IGFjdGlvbiwgY29ubmVjdGlvblN0YXR1cyB3aWxsIG5vdCBiZSB1bmRlZmluZWQuXG4gICAgICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0dXMgPT09IENPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgIC8vIElmIERpcmVjdExpbmVKUyBjaGFuZ2VkIGNvbm5lY3Rpb25TdGF0dXMgdG8gQ09OTkVDVElORywgd2Ugd2lsbCB0cmVhdCBpdCBhcyByZWNvbm5lY3Qgc3RhdHVzLlxuICAgICAgICAgICAgeWllbGQgcnVuQXN5bmNFZmZlY3RVbnRpbERpc2Nvbm5lY3QoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBSRUNPTk5FQ1QsXG4gICAgICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IGRpcmVjdExpbmUgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAoKSA9PiBjYWxsKHJlY29ubmVjdFNhZ2EpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXR1cyAhPT0gT05MSU5FKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3Rpb25TdGF0dXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8ga2lsbCB0aGUgY29ubmVjdGlvbiBiZWNhdXNlIERpcmVjdExpbmVKUyB3YW50IHRvIGNsb3NlIGl0LlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gc3RhdHVzIGNoYW5nZWQgdG8gJHtjb25uZWN0aW9uU3RhdHVzfWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gU29tZW9uZSBkaXNwYXRjaGVkIGRpc2Nvbm5lY3QgYWN0aW9uLlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGVuZERpcmVjdExpbmUoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGlzY29ubmVjdE1ldGEgPSB7IGVycm9yIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHlpZWxkIGNhbmNlbCh1cGRhdGVDb25uZWN0aW9uU3RhdHVzVGFzayk7XG5cbiAgICAgIC8vIEV2ZW4gaWYgdGhlIGNvbm5lY3Rpb24gaXMgaW50ZXJydXB0ZWQsIHdlIHdpbGwgc3RpbGwgZW1pdCBESVNDT05ORUNUX1BFTkRJTkcuXG4gICAgICAvLyBUaGlzIHdpbGwgbWFrZXMgaGFuZGxpbmcgbG9naWMgZWFzaWVyLiBJZiBDT05ORUNUX0ZVTEZJTExFRCwgd2UgZ3VhcmFudGVlIERJU0NPTk5FQ1RfUEVORElORy5cbiAgICAgIHlpZWxkIGZvcmtQdXQoXG4gICAgICAgIHsgdHlwZTogRElTQ09OTkVDVF9QRU5ESU5HLCBtZXRhOiBkaXNjb25uZWN0TWV0YSwgcGF5bG9hZDogeyBkaXJlY3RMaW5lIH0gfSxcbiAgICAgICAgeyB0eXBlOiBESVNDT05ORUNUX0ZVTEZJTExFRCwgbWV0YTogZGlzY29ubmVjdE1ldGEsIHBheWxvYWQ6IHsgZGlyZWN0TGluZSB9IH1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iXX0=